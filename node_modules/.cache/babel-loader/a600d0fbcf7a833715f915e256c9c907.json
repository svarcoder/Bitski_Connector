{"ast":null,"code":"import BN from 'bn.js';\n/**\n * parseNumber\n * Converts a value that represents a number into a hex value.\n * @param arg {string | number | BN} A number value to convert to hex.\n * Can be a regular number, base-10 string, base-16 string, or BN instance.\n * @returns {BN} BN instance representing the number\n *\n * (Adapted from ethereumjs-abi)\n */\nfunction parseNumber(arg) {\n  const type = typeof arg;\n  if (type === 'string') {\n    if (arg.substr(0, 2) === '0x') {\n      return new BN(arg.substr(2), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n}\nfunction parseBitWidth(type, offset) {\n  // default to 256 bit if not specified\n  let size = 256;\n  // If type string is longer than offset, parse bits from the type string\n  if (type.length > offset) {\n    size = parseInt(type.substr(offset), 10);\n  }\n  // bit width must be a multiple of 8, and in the range 8-256.\n  if (size % 8 || size < 8 || size > 256) {\n    throw new Error(`Invalid bit width ${type}`);\n  }\n  return size;\n}\n/**\n * encodeNumber\n * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.\n * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing\n * numbers eth_signTypedData payloads.\n * @param num The value to convert\n * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.\n * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.\n * @returns {string} A hex string formatted as the specified type.\n */\nexport function encodeNumber(num, type) {\n  let compact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (type.startsWith('uint')) {\n    const size = parseBitWidth(type, 4); // start after 'uint'\n    const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n    const parsed = parseNumber(num);\n    // uint can never be negative\n    if (parsed.isNeg()) {\n      throw new Error('Supplied uint is negative');\n    }\n    // Convert to hex, and prepend 0x\n    if (compact) {\n      return '0x' + parsed.toString(16);\n    }\n    return '0x' + parsed.toString(16, length);\n  } else if (type.startsWith('int')) {\n    // bit width must be a multiple of 8, and in the range 8-256.\n    const size = parseBitWidth(type, 3);\n    const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n    const parsed = parseNumber(num);\n    // Convert to twos complement at the bit size from the type, then convert value to hex\n    return '0x' + parsed.toTwos(size).toString(16, length);\n  } else {\n    throw new Error('Invalid type passed');\n  }\n}","map":{"version":3,"names":["BN","parseNumber","arg","type","substr","toArray","Error","parseBitWidth","offset","size","length","parseInt","encodeNumber","num","compact","startsWith","parsed","isNeg","toString","toTwos"],"sources":["/Users/charvai/Desktop/template/node_modules/bitski-provider/dist/utils/parse-utils.js"],"sourcesContent":["import BN from 'bn.js';\n/**\n * parseNumber\n * Converts a value that represents a number into a hex value.\n * @param arg {string | number | BN} A number value to convert to hex.\n * Can be a regular number, base-10 string, base-16 string, or BN instance.\n * @returns {BN} BN instance representing the number\n *\n * (Adapted from ethereumjs-abi)\n */\nfunction parseNumber(arg) {\n    const type = typeof arg;\n    if (type === 'string') {\n        if (arg.substr(0, 2) === '0x') {\n            return new BN(arg.substr(2), 16);\n        }\n        else {\n            return new BN(arg, 10);\n        }\n    }\n    else if (type === 'number') {\n        return new BN(arg);\n    }\n    else if (arg.toArray) {\n        // assume this is a BN for the moment, replace with BN.isBN soon\n        return arg;\n    }\n    else {\n        throw new Error('Argument is not a number');\n    }\n}\nfunction parseBitWidth(type, offset) {\n    // default to 256 bit if not specified\n    let size = 256;\n    // If type string is longer than offset, parse bits from the type string\n    if (type.length > offset) {\n        size = parseInt(type.substr(offset), 10);\n    }\n    // bit width must be a multiple of 8, and in the range 8-256.\n    if (size % 8 || size < 8 || size > 256) {\n        throw new Error(`Invalid bit width ${type}`);\n    }\n    return size;\n}\n/**\n * encodeNumber\n * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.\n * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing\n * numbers eth_signTypedData payloads.\n * @param num The value to convert\n * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.\n * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.\n * @returns {string} A hex string formatted as the specified type.\n */\nexport function encodeNumber(num, type, compact = false) {\n    if (type.startsWith('uint')) {\n        const size = parseBitWidth(type, 4); // start after 'uint'\n        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n        const parsed = parseNumber(num);\n        // uint can never be negative\n        if (parsed.isNeg()) {\n            throw new Error('Supplied uint is negative');\n        }\n        // Convert to hex, and prepend 0x\n        if (compact) {\n            return '0x' + parsed.toString(16);\n        }\n        return '0x' + parsed.toString(16, length);\n    }\n    else if (type.startsWith('int')) {\n        // bit width must be a multiple of 8, and in the range 8-256.\n        const size = parseBitWidth(type, 3);\n        const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.\n        const parsed = parseNumber(num);\n        // Convert to twos complement at the bit size from the type, then convert value to hex\n        return '0x' + parsed.toTwos(size).toString(16, length);\n    }\n    else {\n        throw new Error('Invalid type passed');\n    }\n}\n"],"mappings":"AAAA,OAAOA,EAAE,MAAM,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAW,CAACC,GAAG,EAAE;EACtB,MAAMC,IAAI,GAAG,OAAOD,GAAG;EACvB,IAAIC,IAAI,KAAK,QAAQ,EAAE;IACnB,IAAID,GAAG,CAACE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;MAC3B,OAAO,IAAIJ,EAAE,CAACE,GAAG,CAACE,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;IACpC,CAAC,MACI;MACD,OAAO,IAAIJ,EAAE,CAACE,GAAG,EAAE,EAAE,CAAC;IAC1B;EACJ,CAAC,MACI,IAAIC,IAAI,KAAK,QAAQ,EAAE;IACxB,OAAO,IAAIH,EAAE,CAACE,GAAG,CAAC;EACtB,CAAC,MACI,IAAIA,GAAG,CAACG,OAAO,EAAE;IAClB;IACA,OAAOH,GAAG;EACd,CAAC,MACI;IACD,MAAM,IAAII,KAAK,CAAC,0BAA0B,CAAC;EAC/C;AACJ;AACA,SAASC,aAAa,CAACJ,IAAI,EAAEK,MAAM,EAAE;EACjC;EACA,IAAIC,IAAI,GAAG,GAAG;EACd;EACA,IAAIN,IAAI,CAACO,MAAM,GAAGF,MAAM,EAAE;IACtBC,IAAI,GAAGE,QAAQ,CAACR,IAAI,CAACC,MAAM,CAACI,MAAM,CAAC,EAAE,EAAE,CAAC;EAC5C;EACA;EACA,IAAIC,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,GAAG,EAAE;IACpC,MAAM,IAAIH,KAAK,CAAE,qBAAoBH,IAAK,EAAC,CAAC;EAChD;EACA,OAAOM,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,YAAY,CAACC,GAAG,EAAEV,IAAI,EAAmB;EAAA,IAAjBW,OAAO,uEAAG,KAAK;EACnD,IAAIX,IAAI,CAACY,UAAU,CAAC,MAAM,CAAC,EAAE;IACzB,MAAMN,IAAI,GAAGF,aAAa,CAACJ,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;IACrC,MAAMO,MAAM,GAAGD,IAAI,GAAG,CAAC,CAAC,CAAC;IACzB,MAAMO,MAAM,GAAGf,WAAW,CAACY,GAAG,CAAC;IAC/B;IACA,IAAIG,MAAM,CAACC,KAAK,EAAE,EAAE;MAChB,MAAM,IAAIX,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA;IACA,IAAIQ,OAAO,EAAE;MACT,OAAO,IAAI,GAAGE,MAAM,CAACE,QAAQ,CAAC,EAAE,CAAC;IACrC;IACA,OAAO,IAAI,GAAGF,MAAM,CAACE,QAAQ,CAAC,EAAE,EAAER,MAAM,CAAC;EAC7C,CAAC,MACI,IAAIP,IAAI,CAACY,UAAU,CAAC,KAAK,CAAC,EAAE;IAC7B;IACA,MAAMN,IAAI,GAAGF,aAAa,CAACJ,IAAI,EAAE,CAAC,CAAC;IACnC,MAAMO,MAAM,GAAGD,IAAI,GAAG,CAAC,CAAC,CAAC;IACzB,MAAMO,MAAM,GAAGf,WAAW,CAACY,GAAG,CAAC;IAC/B;IACA,OAAO,IAAI,GAAGG,MAAM,CAACG,MAAM,CAACV,IAAI,CAAC,CAACS,QAAQ,CAAC,EAAE,EAAER,MAAM,CAAC;EAC1D,CAAC,MACI;IACD,MAAM,IAAIJ,KAAK,CAAC,qBAAqB,CAAC;EAC1C;AACJ"},"metadata":{},"sourceType":"module"}