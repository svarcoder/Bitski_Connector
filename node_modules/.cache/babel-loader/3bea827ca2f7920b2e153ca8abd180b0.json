{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that automatically populates missing transaction details.\n * This is needed because it has become common to submit transactions with\n * only some of the parameters and rely on the provider or node to fill in the rest.\n */\nexport class TransactionValidatorSubprovider extends Subprovider {\n  constructor() {\n    let minGasPrice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super();\n    this.minGasPrice = minGasPrice;\n  }\n  handleRequest(payload, next, _) {\n    // Only handle transactions\n    if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {\n      this.populateTransactionFields(payload).then(() => {\n        // Payload was modified. Continue.\n        next();\n      }).catch(() => {\n        // Fall through if we cannot populate fields\n        next();\n      });\n    } else {\n      next();\n    }\n  }\n  // Examine transaction and populate missing params\n  async populateTransactionFields(payload) {\n    const params = payload.params || [];\n    let transaction = {};\n    if (params.length > 0) {\n      transaction = params[0];\n    }\n    const promises = [];\n    // Populate missing from with default account\n    if (transaction.from === undefined) {\n      const accounts = await this.getAccounts();\n      transaction.from = accounts[0];\n    }\n    // Populate missing gasPrice\n    if (transaction.gasPrice === undefined) {\n      promises.push(this.estimateGasPrice());\n    } else {\n      promises.push(transaction.gasPrice);\n    }\n    // Populate missing nonce\n    if (transaction.nonce === undefined) {\n      promises.push(this.getNonce(transaction.from));\n    } else {\n      promises.push(transaction.nonce);\n    }\n    // Populate missing gas\n    if (transaction.gas === undefined) {\n      promises.push(this.estimateGas(transaction));\n    } else {\n      promises.push(transaction.gas);\n    }\n    // Execute promises\n    const values = await Promise.all(promises);\n    // Update parameters with loaded values. Must be very careful with the indexes here.\n    transaction.gasPrice = values[0];\n    transaction.nonce = values[1];\n    transaction.gas = values[2];\n    // Set the params on the payload\n    payload.params[0] = transaction;\n    return payload;\n  }\n  async getNonce(address) {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_getTransactionCount',\n      params: [address, 'latest']\n    };\n    return this.performRequest(request);\n  }\n  async getAccounts() {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_accounts',\n      params: []\n    };\n    return this.performRequest(request);\n  }\n  async estimateGas(transaction) {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_estimateGas',\n      params: [transaction]\n    };\n    return this.performRequest(request);\n  }\n  async estimateGasPrice() {\n    const request = {\n      id: 0,\n      jsonrpc: '2.0',\n      method: 'eth_gasPrice',\n      params: []\n    };\n    return this.performRequest(request).then(gasPrice => {\n      if (gasPrice === '0x0') {\n        return `0x${this.minGasPrice.toString(16)}`;\n      }\n      return gasPrice;\n    });\n  }\n  // Wraps emitPayload in a promise\n  performRequest(payload) {\n    return new Promise((fulfill, reject) => {\n      this.emitPayload(payload, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          fulfill(result.result);\n        }\n      });\n    });\n  }\n}","map":{"version":3,"names":["Subprovider","TransactionValidatorSubprovider","constructor","minGasPrice","handleRequest","payload","next","_","method","populateTransactionFields","then","catch","params","transaction","length","promises","from","undefined","accounts","getAccounts","gasPrice","push","estimateGasPrice","nonce","getNonce","gas","estimateGas","values","Promise","all","address","request","id","jsonrpc","performRequest","toString","fulfill","reject","emitPayload","err","result"],"sources":["/Users/charvai/Desktop/template/node_modules/bitski-provider/dist/subproviders/transaction-validator.js"],"sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\n/**\n * A subprovider that automatically populates missing transaction details.\n * This is needed because it has become common to submit transactions with\n * only some of the parameters and rely on the provider or node to fill in the rest.\n */\nexport class TransactionValidatorSubprovider extends Subprovider {\n    constructor(minGasPrice = 0) {\n        super();\n        this.minGasPrice = minGasPrice;\n    }\n    handleRequest(payload, next, _) {\n        // Only handle transactions\n        if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {\n            this.populateTransactionFields(payload)\n                .then(() => {\n                // Payload was modified. Continue.\n                next();\n            })\n                .catch(() => {\n                // Fall through if we cannot populate fields\n                next();\n            });\n        }\n        else {\n            next();\n        }\n    }\n    // Examine transaction and populate missing params\n    async populateTransactionFields(payload) {\n        const params = payload.params || [];\n        let transaction = {};\n        if (params.length > 0) {\n            transaction = params[0];\n        }\n        const promises = [];\n        // Populate missing from with default account\n        if (transaction.from === undefined) {\n            const accounts = await this.getAccounts();\n            transaction.from = accounts[0];\n        }\n        // Populate missing gasPrice\n        if (transaction.gasPrice === undefined) {\n            promises.push(this.estimateGasPrice());\n        }\n        else {\n            promises.push(transaction.gasPrice);\n        }\n        // Populate missing nonce\n        if (transaction.nonce === undefined) {\n            promises.push(this.getNonce(transaction.from));\n        }\n        else {\n            promises.push(transaction.nonce);\n        }\n        // Populate missing gas\n        if (transaction.gas === undefined) {\n            promises.push(this.estimateGas(transaction));\n        }\n        else {\n            promises.push(transaction.gas);\n        }\n        // Execute promises\n        const values = await Promise.all(promises);\n        // Update parameters with loaded values. Must be very careful with the indexes here.\n        transaction.gasPrice = values[0];\n        transaction.nonce = values[1];\n        transaction.gas = values[2];\n        // Set the params on the payload\n        payload.params[0] = transaction;\n        return payload;\n    }\n    async getNonce(address) {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_getTransactionCount',\n            params: [address, 'latest'],\n        };\n        return this.performRequest(request);\n    }\n    async getAccounts() {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_accounts',\n            params: [],\n        };\n        return this.performRequest(request);\n    }\n    async estimateGas(transaction) {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_estimateGas',\n            params: [transaction],\n        };\n        return this.performRequest(request);\n    }\n    async estimateGasPrice() {\n        const request = {\n            id: 0,\n            jsonrpc: '2.0',\n            method: 'eth_gasPrice',\n            params: [],\n        };\n        return this.performRequest(request).then((gasPrice) => {\n            if (gasPrice === '0x0') {\n                return `0x${this.minGasPrice.toString(16)}`;\n            }\n            return gasPrice;\n        });\n    }\n    // Wraps emitPayload in a promise\n    performRequest(payload) {\n        return new Promise((fulfill, reject) => {\n            this.emitPayload(payload, (err, result) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    fulfill(result.result);\n                }\n            });\n        });\n    }\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,+BAA+B,SAASD,WAAW,CAAC;EAC7DE,WAAW,GAAkB;IAAA,IAAjBC,WAAW,uEAAG,CAAC;IACvB,KAAK,EAAE;IACP,IAAI,CAACA,WAAW,GAAGA,WAAW;EAClC;EACAC,aAAa,CAACC,OAAO,EAAEC,IAAI,EAAEC,CAAC,EAAE;IAC5B;IACA,IAAIF,OAAO,CAACG,MAAM,KAAK,qBAAqB,IAAIH,OAAO,CAACG,MAAM,KAAK,qBAAqB,EAAE;MACtF,IAAI,CAACC,yBAAyB,CAACJ,OAAO,CAAC,CAClCK,IAAI,CAAC,MAAM;QACZ;QACAJ,IAAI,EAAE;MACV,CAAC,CAAC,CACGK,KAAK,CAAC,MAAM;QACb;QACAL,IAAI,EAAE;MACV,CAAC,CAAC;IACN,CAAC,MACI;MACDA,IAAI,EAAE;IACV;EACJ;EACA;EACA,MAAMG,yBAAyB,CAACJ,OAAO,EAAE;IACrC,MAAMO,MAAM,GAAGP,OAAO,CAACO,MAAM,IAAI,EAAE;IACnC,IAAIC,WAAW,GAAG,CAAC,CAAC;IACpB,IAAID,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;MACnBD,WAAW,GAAGD,MAAM,CAAC,CAAC,CAAC;IAC3B;IACA,MAAMG,QAAQ,GAAG,EAAE;IACnB;IACA,IAAIF,WAAW,CAACG,IAAI,KAAKC,SAAS,EAAE;MAChC,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACC,WAAW,EAAE;MACzCN,WAAW,CAACG,IAAI,GAAGE,QAAQ,CAAC,CAAC,CAAC;IAClC;IACA;IACA,IAAIL,WAAW,CAACO,QAAQ,KAAKH,SAAS,EAAE;MACpCF,QAAQ,CAACM,IAAI,CAAC,IAAI,CAACC,gBAAgB,EAAE,CAAC;IAC1C,CAAC,MACI;MACDP,QAAQ,CAACM,IAAI,CAACR,WAAW,CAACO,QAAQ,CAAC;IACvC;IACA;IACA,IAAIP,WAAW,CAACU,KAAK,KAAKN,SAAS,EAAE;MACjCF,QAAQ,CAACM,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACX,WAAW,CAACG,IAAI,CAAC,CAAC;IAClD,CAAC,MACI;MACDD,QAAQ,CAACM,IAAI,CAACR,WAAW,CAACU,KAAK,CAAC;IACpC;IACA;IACA,IAAIV,WAAW,CAACY,GAAG,KAAKR,SAAS,EAAE;MAC/BF,QAAQ,CAACM,IAAI,CAAC,IAAI,CAACK,WAAW,CAACb,WAAW,CAAC,CAAC;IAChD,CAAC,MACI;MACDE,QAAQ,CAACM,IAAI,CAACR,WAAW,CAACY,GAAG,CAAC;IAClC;IACA;IACA,MAAME,MAAM,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACd,QAAQ,CAAC;IAC1C;IACAF,WAAW,CAACO,QAAQ,GAAGO,MAAM,CAAC,CAAC,CAAC;IAChCd,WAAW,CAACU,KAAK,GAAGI,MAAM,CAAC,CAAC,CAAC;IAC7Bd,WAAW,CAACY,GAAG,GAAGE,MAAM,CAAC,CAAC,CAAC;IAC3B;IACAtB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,GAAGC,WAAW;IAC/B,OAAOR,OAAO;EAClB;EACA,MAAMmB,QAAQ,CAACM,OAAO,EAAE;IACpB,MAAMC,OAAO,GAAG;MACZC,EAAE,EAAE,CAAC;MACLC,OAAO,EAAE,KAAK;MACdzB,MAAM,EAAE,yBAAyB;MACjCI,MAAM,EAAE,CAACkB,OAAO,EAAE,QAAQ;IAC9B,CAAC;IACD,OAAO,IAAI,CAACI,cAAc,CAACH,OAAO,CAAC;EACvC;EACA,MAAMZ,WAAW,GAAG;IAChB,MAAMY,OAAO,GAAG;MACZC,EAAE,EAAE,CAAC;MACLC,OAAO,EAAE,KAAK;MACdzB,MAAM,EAAE,cAAc;MACtBI,MAAM,EAAE;IACZ,CAAC;IACD,OAAO,IAAI,CAACsB,cAAc,CAACH,OAAO,CAAC;EACvC;EACA,MAAML,WAAW,CAACb,WAAW,EAAE;IAC3B,MAAMkB,OAAO,GAAG;MACZC,EAAE,EAAE,CAAC;MACLC,OAAO,EAAE,KAAK;MACdzB,MAAM,EAAE,iBAAiB;MACzBI,MAAM,EAAE,CAACC,WAAW;IACxB,CAAC;IACD,OAAO,IAAI,CAACqB,cAAc,CAACH,OAAO,CAAC;EACvC;EACA,MAAMT,gBAAgB,GAAG;IACrB,MAAMS,OAAO,GAAG;MACZC,EAAE,EAAE,CAAC;MACLC,OAAO,EAAE,KAAK;MACdzB,MAAM,EAAE,cAAc;MACtBI,MAAM,EAAE;IACZ,CAAC;IACD,OAAO,IAAI,CAACsB,cAAc,CAACH,OAAO,CAAC,CAACrB,IAAI,CAAEU,QAAQ,IAAK;MACnD,IAAIA,QAAQ,KAAK,KAAK,EAAE;QACpB,OAAQ,KAAI,IAAI,CAACjB,WAAW,CAACgC,QAAQ,CAAC,EAAE,CAAE,EAAC;MAC/C;MACA,OAAOf,QAAQ;IACnB,CAAC,CAAC;EACN;EACA;EACAc,cAAc,CAAC7B,OAAO,EAAE;IACpB,OAAO,IAAIuB,OAAO,CAAC,CAACQ,OAAO,EAAEC,MAAM,KAAK;MACpC,IAAI,CAACC,WAAW,CAACjC,OAAO,EAAE,CAACkC,GAAG,EAAEC,MAAM,KAAK;QACvC,IAAID,GAAG,EAAE;UACLF,MAAM,CAACE,GAAG,CAAC;QACf,CAAC,MACI;UACDH,OAAO,CAACI,MAAM,CAACA,MAAM,CAAC;QAC1B;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;AACJ"},"metadata":{},"sourceType":"module"}