{"ast":null,"code":"const clone = require('clone');\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\nconst cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload;\nmodule.exports = createInflightCache;\nfunction createInflightCache() {\n  const inflightRequests = {};\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) return next();\n    // get cacheId, if cacheable\n    const cacheId = cacheIdentifierForPayload(req);\n    // if not cacheable, skip\n    if (!cacheId) return next();\n    // check for matching requests\n    let activeRequestHandlers = inflightRequests[cacheId];\n    // if found, wait for the active request to be handled\n    if (activeRequestHandlers) {\n      // setup the response listener and wait for it to be called\n      // it will handle copying the result and request fields\n      await createActiveRequestHandler(res, activeRequestHandlers);\n      return;\n    }\n    // setup response handler array for subsequent requests\n    activeRequestHandlers = [];\n    inflightRequests[cacheId] = activeRequestHandlers;\n    // allow request to be handled normally\n    await next();\n    // clear inflight requests\n    delete inflightRequests[cacheId];\n    // schedule activeRequestHandlers to be handled\n    handleActiveRequest(res, activeRequestHandlers);\n    // complete\n    return;\n  });\n  function createActiveRequestHandler(res, activeRequestHandlers) {\n    const {\n      resolve,\n      promise\n    } = deferredPromise();\n    activeRequestHandlers.push(handledRes => {\n      // append a copy of the result and error to the response\n      res.result = clone(handledRes.result);\n      res.error = clone(handledRes.error);\n      resolve();\n    });\n    return promise;\n  }\n  function handleActiveRequest(res, activeRequestHandlers) {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach(handler => {\n        try {\n          handler(res);\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err);\n        }\n      });\n    });\n  }\n}\nfunction deferredPromise() {\n  let resolve;\n  const promise = new Promise(_resolve => {\n    resolve = _resolve;\n  });\n  return {\n    resolve,\n    promise\n  };\n}","map":{"version":3,"names":["clone","require","createAsyncMiddleware","cacheIdentifierForPayload","module","exports","createInflightCache","inflightRequests","req","res","next","skipCache","cacheId","activeRequestHandlers","createActiveRequestHandler","handleActiveRequest","resolve","promise","deferredPromise","push","handledRes","result","error","setTimeout","forEach","handler","err","console","Promise","_resolve"],"sources":["/Users/charvai/Desktop/template/node_modules/eth-json-rpc-middleware/inflight-cache.js"],"sourcesContent":["const clone = require('clone')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\nconst cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload\n\nmodule.exports = createInflightCache\n\n\nfunction createInflightCache () {\n  const inflightRequests = {}\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) return next()\n    // get cacheId, if cacheable\n    const cacheId = cacheIdentifierForPayload(req)\n    // if not cacheable, skip\n    if (!cacheId) return next()\n    // check for matching requests\n    let activeRequestHandlers = inflightRequests[cacheId]\n    // if found, wait for the active request to be handled\n    if (activeRequestHandlers) {\n      // setup the response listener and wait for it to be called\n      // it will handle copying the result and request fields\n      await createActiveRequestHandler(res, activeRequestHandlers)\n      return\n    }\n    // setup response handler array for subsequent requests\n    activeRequestHandlers = []\n    inflightRequests[cacheId] = activeRequestHandlers\n    // allow request to be handled normally\n    await next()\n    // clear inflight requests\n    delete inflightRequests[cacheId]\n    // schedule activeRequestHandlers to be handled\n    handleActiveRequest(res, activeRequestHandlers)\n    // complete\n    return\n  })\n\n  function createActiveRequestHandler(res, activeRequestHandlers) {\n    const { resolve, promise } = deferredPromise()\n    activeRequestHandlers.push((handledRes) => {\n      // append a copy of the result and error to the response\n      res.result = clone(handledRes.result)\n      res.error = clone(handledRes.error)\n      resolve()\n    })\n    return promise\n  }\n\n  function handleActiveRequest(res, activeRequestHandlers) {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach((handler) => {\n        try {\n          handler(res)\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err)\n        }\n      })\n    })\n  }\n}\n\nfunction deferredPromise() {\n  let resolve\n  const promise = new Promise(_resolve => { resolve = _resolve })\n  return { resolve, promise }\n}\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,2CAA2C,CAAC;AAClF,MAAME,yBAAyB,GAAGF,OAAO,CAAC,eAAe,CAAC,CAACE,yBAAyB;AAEpFC,MAAM,CAACC,OAAO,GAAGC,mBAAmB;AAGpC,SAASA,mBAAmB,GAAI;EAC9B,MAAMC,gBAAgB,GAAG,CAAC,CAAC;EAE3B,OAAOL,qBAAqB,CAAC,OAAOM,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;IACrD;IACA,IAAIF,GAAG,CAACG,SAAS,EAAE,OAAOD,IAAI,EAAE;IAChC;IACA,MAAME,OAAO,GAAGT,yBAAyB,CAACK,GAAG,CAAC;IAC9C;IACA,IAAI,CAACI,OAAO,EAAE,OAAOF,IAAI,EAAE;IAC3B;IACA,IAAIG,qBAAqB,GAAGN,gBAAgB,CAACK,OAAO,CAAC;IACrD;IACA,IAAIC,qBAAqB,EAAE;MACzB;MACA;MACA,MAAMC,0BAA0B,CAACL,GAAG,EAAEI,qBAAqB,CAAC;MAC5D;IACF;IACA;IACAA,qBAAqB,GAAG,EAAE;IAC1BN,gBAAgB,CAACK,OAAO,CAAC,GAAGC,qBAAqB;IACjD;IACA,MAAMH,IAAI,EAAE;IACZ;IACA,OAAOH,gBAAgB,CAACK,OAAO,CAAC;IAChC;IACAG,mBAAmB,CAACN,GAAG,EAAEI,qBAAqB,CAAC;IAC/C;IACA;EACF,CAAC,CAAC;EAEF,SAASC,0BAA0B,CAACL,GAAG,EAAEI,qBAAqB,EAAE;IAC9D,MAAM;MAAEG,OAAO;MAAEC;IAAQ,CAAC,GAAGC,eAAe,EAAE;IAC9CL,qBAAqB,CAACM,IAAI,CAAEC,UAAU,IAAK;MACzC;MACAX,GAAG,CAACY,MAAM,GAAGrB,KAAK,CAACoB,UAAU,CAACC,MAAM,CAAC;MACrCZ,GAAG,CAACa,KAAK,GAAGtB,KAAK,CAACoB,UAAU,CAACE,KAAK,CAAC;MACnCN,OAAO,EAAE;IACX,CAAC,CAAC;IACF,OAAOC,OAAO;EAChB;EAEA,SAASF,mBAAmB,CAACN,GAAG,EAAEI,qBAAqB,EAAE;IACvD;IACAU,UAAU,CAAC,MAAM;MACfV,qBAAqB,CAACW,OAAO,CAAEC,OAAO,IAAK;QACzC,IAAI;UACFA,OAAO,CAAChB,GAAG,CAAC;QACd,CAAC,CAAC,OAAOiB,GAAG,EAAE;UACZ;UACAC,OAAO,CAACL,KAAK,CAACI,GAAG,CAAC;QACpB;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;AACF;AAEA,SAASR,eAAe,GAAG;EACzB,IAAIF,OAAO;EACX,MAAMC,OAAO,GAAG,IAAIW,OAAO,CAACC,QAAQ,IAAI;IAAEb,OAAO,GAAGa,QAAQ;EAAC,CAAC,CAAC;EAC/D,OAAO;IAAEb,OAAO;IAAEC;EAAQ,CAAC;AAC7B"},"metadata":{},"sourceType":"script"}