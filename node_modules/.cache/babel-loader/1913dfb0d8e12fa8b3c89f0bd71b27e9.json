{"ast":null,"code":"\"use strict\";\n\nimport { ethers } from \"ethers\";\n// @TODO: Keep a per-NonceManager pool of sent but unmined transactions for\n//        rebroadcasting, in case we overrun the transaction pool\nexport class NonceManager extends ethers.Signer {\n  constructor(signer) {\n    super();\n    this._deltaCount = 0;\n    ethers.utils.defineReadOnly(this, \"signer\", signer);\n    ethers.utils.defineReadOnly(this, \"provider\", signer.provider || null);\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  getAddress() {\n    return this.signer.getAddress();\n  }\n  getTransactionCount(blockTag) {\n    if (blockTag === \"pending\") {\n      if (!this._initialPromise) {\n        this._initialPromise = this.signer.getTransactionCount(\"pending\");\n      }\n      const deltaCount = this._deltaCount;\n      return this._initialPromise.then(initial => initial + deltaCount);\n    }\n    return this.signer.getTransactionCount(blockTag);\n  }\n  setTransactionCount(transactionCount) {\n    this._initialPromise = Promise.resolve(transactionCount).then(nonce => {\n      return ethers.BigNumber.from(nonce).toNumber();\n    });\n    this._deltaCount = 0;\n  }\n  incrementTransactionCount(count) {\n    this._deltaCount += count == null ? 1 : count;\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n    ;\n  }\n  signTransaction(transaction) {\n    return this.signer.signTransaction(transaction);\n  }\n  sendTransaction(transaction) {\n    if (transaction.nonce == null) {\n      transaction = ethers.utils.shallowCopy(transaction);\n      transaction.nonce = this.getTransactionCount(\"pending\");\n      this.incrementTransactionCount();\n    } else {\n      this.setTransactionCount(transaction.nonce);\n      this._deltaCount++;\n    }\n    return this.signer.sendTransaction(transaction).then(tx => {\n      return tx;\n    });\n  }\n}","map":{"version":3,"sources":["../src.ts/nonce-manager.ts"],"names":[],"mappings":"AAAA,YAAY;;AAEZ,SAAS,MAAM,QAAQ,QAAQ;AAE/B;AACA;AAEA,OAAM,MAAO,YAAa,SAAQ,MAAM,CAAC,MAAM,CAAA;EAM3C,WAAA,CAAY,MAAqB,EAAA;IAC7B,KAAK,EAAE;IACP,IAAI,CAAC,WAAW,GAAG,CAAC;IACpB,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC;IACnD,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC;EAC1E;EAEA,OAAO,CAAC,QAAmC,EAAA;IACvC,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC1D;EAEA,UAAU,GAAA;IACN,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;EACnC;EAEA,mBAAmB,CAAC,QAAoC,EAAA;IACpD,IAAI,QAAQ,KAAK,SAAS,EAAE;MACxB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;QACvB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC;MACpE;MACD,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW;MACnC,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAE,OAAO,IAAM,OAAO,GAAG,UAAW,CAAC;IACxE;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,QAAQ,CAAC;EACpD;EAEA,mBAAmB,CAAC,gBAAoE,EAAA;IACpF,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAE,KAAK,IAAI;MACpE,OAAO,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE;IAClD,CAAC,CAAC;IACF,IAAI,CAAC,WAAW,GAAG,CAAC;EACxB;EAEA,yBAAyB,CAAC,KAAc,EAAA;IACpC,IAAI,CAAC,WAAW,IAAM,KAAK,IAAI,IAAI,GAAI,CAAC,GAAE,KAAM;EACpD;EAEA,WAAW,CAAC,OAA8B,EAAA;IACtC,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC;IAAC;EAC5C;EAEA,eAAe,CAAC,WAAyE,EAAA;IACrF,OAAO,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC;EACnD;EAEA,eAAe,CAAC,WAAyE,EAAA;IACrF,IAAI,WAAW,CAAC,KAAK,IAAI,IAAI,EAAE;MAC3B,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,WAAW,CAAC;MACnD,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC;MACvD,IAAI,CAAC,yBAAyB,EAAE;KACnC,MAAM;MACH,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,KAAK,CAAC;MAC3C,IAAI,CAAC,WAAW,EAAE;IACrB;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,IAAI,CAAE,EAAE,IAAI;MACxD,OAAO,EAAE;IACb,CAAC,CAAC;EACN;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { ethers } from \"ethers\";\n// @TODO: Keep a per-NonceManager pool of sent but unmined transactions for\n//        rebroadcasting, in case we overrun the transaction pool\nexport class NonceManager extends ethers.Signer {\n    constructor(signer) {\n        super();\n        this._deltaCount = 0;\n        ethers.utils.defineReadOnly(this, \"signer\", signer);\n        ethers.utils.defineReadOnly(this, \"provider\", signer.provider || null);\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    getAddress() {\n        return this.signer.getAddress();\n    }\n    getTransactionCount(blockTag) {\n        if (blockTag === \"pending\") {\n            if (!this._initialPromise) {\n                this._initialPromise = this.signer.getTransactionCount(\"pending\");\n            }\n            const deltaCount = this._deltaCount;\n            return this._initialPromise.then((initial) => (initial + deltaCount));\n        }\n        return this.signer.getTransactionCount(blockTag);\n    }\n    setTransactionCount(transactionCount) {\n        this._initialPromise = Promise.resolve(transactionCount).then((nonce) => {\n            return ethers.BigNumber.from(nonce).toNumber();\n        });\n        this._deltaCount = 0;\n    }\n    incrementTransactionCount(count) {\n        this._deltaCount += ((count == null) ? 1 : count);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n        ;\n    }\n    signTransaction(transaction) {\n        return this.signer.signTransaction(transaction);\n    }\n    sendTransaction(transaction) {\n        if (transaction.nonce == null) {\n            transaction = ethers.utils.shallowCopy(transaction);\n            transaction.nonce = this.getTransactionCount(\"pending\");\n            this.incrementTransactionCount();\n        }\n        else {\n            this.setTransactionCount(transaction.nonce);\n            this._deltaCount++;\n        }\n        return this.signer.sendTransaction(transaction).then((tx) => {\n            return tx;\n        });\n    }\n}\n//# sourceMappingURL=nonce-manager.js.map"]},"metadata":{},"sourceType":"module"}