{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, setAPIKey, setEmbedHost, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport createKeccakHash from 'keccak';\nconst log = loglevel.getLogger(\"torus.js\");\nlog.disableAll();\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nclass SomeError extends Error {\n  constructor(_ref) {\n    let {\n      errors,\n      responses,\n      predicate\n    } = _ref;\n    super(\"Unable to resolve enough promises.\");\n    _defineProperty(this, \"errors\", void 0);\n    _defineProperty(this, \"responses\", void 0);\n    _defineProperty(this, \"predicate\", void 0);\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n}\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  return promises.forEach((x, index) => {\n    return x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    }) // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n              const {\n                id,\n                error\n              } = z;\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n            return acc;\n          }, {}));\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => `â€¢ ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass GetOrSetNonceError extends Error {}\nconst kCombinations = (s, k) => {\n  let set = s;\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n  if (k === set.length) {\n    return [set];\n  }\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n  const combs = [];\n  let tailCombs = [];\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n  return combs;\n};\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n  return undefined;\n};\nconst keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(\"VerifierLookupRequest\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  })).catch(err => log.error(\"lookup request failed\", err)));\n  return Some(lookupPromises, lookupResults => {\n    const lookupShares = lookupResults.filter(x1 => x1);\n    const errorResult = thresholdSame(lookupShares.map(x2 => x2 && x2.error), ~~(endpoints.length / 2) + 1);\n    const keyResult = thresholdSame(lookupShares.map(x3 => x3 && x3.result), ~~(endpoints.length / 2) + 1);\n    if (keyResult || errorResult) {\n      return Promise.resolve({\n        keyResult,\n        errorResult\n      });\n    }\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`));\n  });\n};\nconst waitKeyLookup = (endpoints, verifier, verifierId, timeout) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n  }, timeout);\n});\nconst keyAssign = async _ref => {\n  let {\n    endpoints,\n    torusNodePubs,\n    lastPoint,\n    firstPoint,\n    verifier,\n    verifierId,\n    signerHost,\n    network\n  } = _ref;\n  let nodeNum;\n  let initialPoint;\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length);\n    initialPoint = nodeNum;\n  } else {\n    nodeNum = lastPoint % endpoints.length;\n  }\n  if (nodeNum === firstPoint) throw new Error(\"Looped through all\");\n  if (firstPoint !== undefined) initialPoint = firstPoint;\n  const data = generateJsonRPCObject(\"KeyAssign\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  });\n  try {\n    const signedData = await post(signerHost, data, {\n      headers: {\n        pubKeyX: torusNodePubs[nodeNum].X,\n        pubKeyY: torusNodePubs[nodeNum].Y,\n        network\n      }\n    }, {\n      useAPIKey: true\n    });\n    return await post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    });\n  } catch (error) {\n    log.error(error);\n    const acceptedErrorMsgs = [\n    // Slow node\n    \"Timed out\",\n    // Happens when the node is not reachable (dns issue etc)\n    \"TypeError: Failed to fetch\", \"TypeError: cancelled\", \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n    ];\n\n    if (acceptedErrorMsgs.includes(error.message)) return keyAssign({\n      endpoints,\n      torusNodePubs,\n      lastPoint: nodeNum + 1,\n      firstPoint: initialPoint,\n      verifier,\n      verifierId,\n      signerHost,\n      network\n    });\n    throw new Error(`Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || \"\"}`);\n  }\n};\nfunction keccak256(a) {\n  const hash = createKeccakHash(\"keccak256\").update(a).digest().toString(\"hex\");\n  return `0x${hash}`;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// of Torus nodes to handle malicious node responses\n\nclass Torus {\n  constructor() {\n    let {\n      enableOneKey = false,\n      metadataHost = \"https://metadata.tor.us\",\n      allowHost = \"https://signer.tor.us/api/allow\",\n      signerHost = \"https://signer.tor.us/api/sign\",\n      serverTimeOffset = 0,\n      network = \"mainnet\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"metadataHost\", void 0);\n    _defineProperty(this, \"allowHost\", void 0);\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n    _defineProperty(this, \"enableOneKey\", void 0);\n    _defineProperty(this, \"signerHost\", void 0);\n    _defineProperty(this, \"network\", void 0);\n    _defineProperty(this, \"ec\", void 0);\n    this.ec = new ec(\"secp256k1\");\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n  static enableLogging() {\n    let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (v) log.enableAll();else log.disableAll();\n  }\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n\n  async getUserTypeAndAddress(endpoints, torusNodePubs, _ref) {\n    let {\n      verifier,\n      verifierId\n    } = _ref;\n    let doesKeyAssign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n    let isNewKey = false;\n    let finalKeyResult;\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      if (!doesKeyAssign) {\n        throw new Error(\"Verifier + VerifierID has not yet been assigned\");\n      }\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n    if (finalKeyResult) {\n      const {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n      try {\n        nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n        nonce = new BN(nonceResult.nonce || \"0\", 16);\n      } catch {\n        throw new GetOrSetNonceError();\n      }\n      if (nonceResult.typeOfUser === \"v1\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      } else if (nonceResult.typeOfUser === \"v2\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPublic({\n          x: nonceResult.pubNonce.x,\n          y: nonceResult.pubNonce.y\n        }).getPublic());\n      } else {\n        throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n      }\n      const finalX = modifiedPubKey.getX().toString(16);\n      const finalY = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      if (nonceResult.typeOfUser === \"v1\") return {\n        typeOfUser: nonceResult.typeOfUser,\n        nonce,\n        X: finalX,\n        Y: finalY,\n        address\n      };else if (nonceResult.typeOfUser === \"v2\") {\n        return {\n          typeOfUser: nonceResult.typeOfUser,\n          nonce,\n          pubNonce: nonceResult.pubNonce,\n          upgraded: nonceResult.upgraded,\n          X: finalX,\n          Y: finalY,\n          address\n        };\n      }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n  async setCustomKey(_ref2) {\n    let {\n      privKeyHex,\n      metadataNonce,\n      torusKeyHex,\n      customKeyHex\n    } = _ref2;\n    let torusKey;\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16);\n    } else {\n      const privKey = new BN(privKeyHex, 16);\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n    }\n    const customKey = new BN(customKeyHex, 16);\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey);\n    await this.setMetadata(data);\n  }\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {\n    let extraParams = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const promiseArr = [];\n    await get(this.allowHost, {\n      headers: {\n        verifier,\n        verifier_id: verifierParams.verifier_id,\n        network: this.network\n      }\n    }, {\n      useAPIKey: true\n    });\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      }\n      */\n    // generate temporary private and public key that is used to secure receive shares\n\n    const tmpKey = generatePrivate();\n    const pubKey = getPublic(tmpKey).toString(\"hex\");\n    const pubKeyX = pubKey.slice(2, 66);\n    const pubKeyY = pubKey.slice(66);\n    const tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(endpoints[i], generateJsonRPCObject(\"CommitmentRequest\", {\n        messageprefix: \"mug00\",\n        tokencommitment: tokenCommitment.slice(2),\n        temppubx: pubKeyX,\n        temppuby: pubKeyY,\n        verifieridentifier: verifier\n      })).catch(err => {\n        log.error(\"commitment\", err);\n      });\n      promiseArr.push(p);\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n\n    return Some(promiseArr, resultArr => {\n      const completedRequests = resultArr.filter(x => {\n        if (!x || typeof x !== \"object\") {\n          return false;\n        }\n        if (x.error) {\n          return false;\n        }\n        return true;\n      });\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr);\n      }\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`));\n    }).then(responses => {\n      const promiseArrRequest = [];\n      const nodeSigs = [];\n      for (let i = 0; i < responses.length; i += 1) {\n        if (responses[i]) nodeSigs.push(responses[i].result);\n      }\n      for (let i = 0; i < endpoints.length; i += 1) {\n        // eslint-disable-next-line promise/no-nesting\n        const p = post(endpoints[i], generateJsonRPCObject(\"ShareRequest\", {\n          encrypted: \"yes\",\n          item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n            idtoken: idToken,\n            nodesignatures: nodeSigs,\n            verifieridentifier: verifier\n          }, extraParams)]\n        })).catch(err => log.error(\"share req\", err));\n        promiseArrRequest.push(p);\n      }\n      return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n        /*\n            ShareRequestResult struct {\n              Keys []KeyAssignment\n            }\n                    / KeyAssignmentPublic -\n            type KeyAssignmentPublic struct {\n              Index     big.Int\n              PublicKey common.Point\n              Threshold int\n              Verifiers map[string][]string // Verifier => VerifierID\n            }\n                   // KeyAssignment -\n            type KeyAssignment struct {\n              KeyAssignmentPublic\n              Share big.Int // Or Si\n            }\n          */\n        // check if threshold number of nodes have returned the same user public key\n        const completedRequests = shareResponses.filter(x => x);\n        const thresholdPublicKey = thresholdSame(shareResponses.map(x => x && x.result && x.result.keys[0].PublicKey), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n        // this is matched against the user public key to ensure that shares are consistent\n\n        if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n          const sharePromises = [];\n          const nodeIndexes = [];\n          for (let i = 0; i < shareResponses.length; i += 1) {\n            var _currentShareResponse, _currentShareResponse2;\n            const currentShareResponse = shareResponses[i];\n            if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {\n              currentShareResponse.result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)));\n              const firstKey = currentShareResponse.result.keys[0];\n              if (firstKey.Metadata) {\n                const metadata = {\n                  ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, \"hex\"),\n                  iv: Buffer.from(firstKey.Metadata.iv, \"hex\"),\n                  mac: Buffer.from(firstKey.Metadata.mac, \"hex\") // mode: Buffer.from(firstKey.Metadata.mode, \"hex\"),\n                };\n\n                sharePromises.push(\n                // eslint-disable-next-line promise/no-nesting\n                decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                  ciphertext: Buffer.from(Buffer.from(firstKey.Share, \"base64\").toString(\"binary\").padStart(64, \"0\"), \"hex\")\n                })).catch(err => log.debug(\"share decryption\", err)));\n              } else {\n                sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, \"0\"), \"hex\")));\n              }\n            } else {\n              sharePromises.push(Promise.resolve(undefined));\n            }\n            nodeIndexes.push(new BN(indexes[i], 16));\n          }\n          const sharesResolved = await Promise.all(sharePromises);\n          if (sharedState.resolved) return undefined;\n          const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n            if (curr) acc.push({\n              index: nodeIndexes[index],\n              value: new BN(curr)\n            });\n            return acc;\n          }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n          const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n          let privateKey = null;\n          for (let j = 0; j < allCombis.length; j += 1) {\n            const currentCombi = allCombis[j];\n            const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index));\n            const shares = currentCombiShares.map(x => x.value);\n            const indices = currentCombiShares.map(x => x.index);\n            const derivedPrivateKey = this.lagrangeInterpolation(shares, indices);\n            if (!derivedPrivateKey) continue;\n            const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n            const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n            const decryptedPubKeyY = decryptedPubKey.slice(66);\n            if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n              privateKey = derivedPrivateKey;\n              break;\n            }\n          }\n          if (privateKey === undefined || privateKey === null) {\n            throw new Error(\"could not derive private key\");\n          }\n          return privateKey;\n        }\n        throw new Error(\"invalid\");\n      });\n    }).then(async returnedKey => {\n      let privateKey = returnedKey;\n      if (!privateKey) throw new Error(\"Invalid private key returned\");\n      const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n      const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n      const decryptedPubKeyY = decryptedPubKey.slice(66);\n      let metadataNonce;\n      if (this.enableOneKey) {\n        const {\n          nonce\n        } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n        metadataNonce = new BN(nonce || \"0\", 16);\n      } else {\n        metadataNonce = await this.getMetadata({\n          pub_key_X: decryptedPubKeyX,\n          pub_key_Y: decryptedPubKeyY\n        });\n      }\n      log.debug(\"> torus.js/retrieveShares\", {\n        privKey: privateKey.toString(16),\n        metadataNonce: metadataNonce.toString(16)\n      });\n      privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n);\n      const ethAddress = this.generateAddressFromPrivKey(privateKey);\n      log.debug(\"> torus.js/retrieveShares\", {\n        ethAddress,\n        privKey: privateKey.toString(16)\n      }); // return reconstructed private key and ethereum address\n\n      return {\n        ethAddress,\n        privKey: privateKey.toString(\"hex\", 64),\n        metadataNonce\n      };\n    });\n  }\n  async getMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, {\n        useAPIKey: true\n      });\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0);\n      }\n      return new BN(metadataResponse.message, 16); // nonce\n    } catch (error) {\n      log.error(\"get metadata error\", error);\n      return new BN(0);\n    }\n  }\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64));\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    };\n  }\n  async setMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, {\n        useAPIKey: true\n      });\n      return metadataResponse.message; // IPFS hash\n    } catch (error) {\n      log.error(\"set metadata error\", error);\n      return \"\";\n    }\n  }\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null;\n    }\n    let secret = new BN(0);\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1);\n      let lower = new BN(1);\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg());\n          upper = upper.umod(this.ec.curve.n);\n          let temp = nodeIndex[i].sub(nodeIndex[j]);\n          temp = temp.umod(this.ec.curve.n);\n          lower = lower.mul(temp).umod(this.ec.curve.n);\n        }\n      }\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n      secret = secret.add(delta);\n    }\n    return secret.umod(this.ec.curve.n);\n  }\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(publicKey, \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({\n      x: publicKeyX.toString(\"hex\", 64),\n      y: publicKeyY.toString(\"hex\", 64)\n    });\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(key.getPublic().encode(\"hex\", false), \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n\n  async getPublicAddress(endpoints, torusNodePubs, _ref3) {\n    let {\n      verifier,\n      verifierId\n    } = _ref3;\n    let isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    log.debug(\"> torus.js/getPublicAddress\", {\n      endpoints,\n      torusNodePubs,\n      verifier,\n      verifierId,\n      isExtended\n    });\n    let finalKeyResult;\n    let isNewKey = false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier not supported\")) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n    } else if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n    log.debug(\"> torus.js/getPublicAddress\", {\n      finalKeyResult,\n      isNewKey\n    });\n    if (finalKeyResult) {\n      var _nonce;\n      let {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n      let typeOfUser;\n      let pubNonce;\n      if (this.enableOneKey) {\n        try {\n          nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n          nonce = new BN(nonceResult.nonce || \"0\", 16);\n          typeOfUser = nonceResult.typeOfUser;\n        } catch {\n          throw new GetOrSetNonceError();\n        }\n        if (nonceResult.typeOfUser === \"v1\") {\n          modifiedPubKey = this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        } else if (nonceResult.typeOfUser === \"v2\") {\n          if (nonceResult.upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic();\n          } else {\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic().add(this.ec.keyFromPublic({\n              x: nonceResult.pubNonce.x,\n              y: nonceResult.pubNonce.y\n            }).getPublic());\n            pubNonce = nonceResult.pubNonce;\n          }\n        } else {\n          throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n        }\n      } else {\n        typeOfUser = \"v1\";\n        nonce = await this.getMetadata({\n          pub_key_X: X,\n          pub_key_Y: Y\n        });\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      }\n      X = modifiedPubKey.getX().toString(16);\n      Y = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      log.debug(\"> torus.js/getPublicAddress\", {\n        X,\n        Y,\n        address,\n        typeOfUser,\n        nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n        pubNonce\n      });\n      if (!isExtended) return address;\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce\n      };\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n  async getOrSetNonce(X, Y, privKey) {\n    let getOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let data;\n    const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey);\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: {\n          data: msg\n        }\n      };\n    }\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true);\n  }\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16);\n    const nonceBN = new BN(nonce, 16);\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString(\"hex\");\n  }\n}\nexport { GetOrSetNonceError, Torus as default, kCombinations, keccak256, keyAssign, keyLookup, thresholdSame, waitKeyLookup };","map":{"version":3,"sources":["../src/loglevel.ts","../src/some.ts","../src/utils.ts","../src/torus.ts"],"names":["log","loglevel","getLogger","disableAll","capitalizeFirstLetter","str","charAt","toUpperCase","slice","SomeError","Error","constructor","errors","responses","predicate","Some","promises","Promise","resolve","reject","finishedCount","sharedState","resolved","errorArr","Array","length","fill","undefined","resultArr","predicateError","forEach","x","index","then","resp","catch","error","finally","data","values","reduce","acc","z","id","startsWith","msg","map","it","join","message","GetOrSetNonceError","kCombinations","s","k","set","from","_","i","cur","combs","tailCombs","j","push","thresholdSame","arr","t","hashMap","JsonStringify","keyLookup","endpoints","verifier","verifierId","lookupPromises","generateJsonRPCObject","verifier_id","toString","err","lookupResults","lookupShares","filter","x1","errorResult","x2","keyResult","x3","result","JSON","stringify","waitKeyLookup","timeout","setTimeout","keyAssign","torusNodePubs","lastPoint","firstPoint","signerHost","network","nodeNum","initialPoint","Math","floor","random","signedData","post","headers","pubKeyX","X","pubKeyY","Y","useAPIKey","acceptedErrorMsgs","includes","keccak256","a","hash","createKeccakHash","update","digest","Torus","enableOneKey","metadataHost","allowHost","serverTimeOffset","ec","EC","enableLogging","v","enableAll","setAPIKey","apiKey","setEmbedHost","embedHost","isGetOrSetNonceError","getUserTypeAndAddress","doesKeyAssign","isNewKey","finalKeyResult","assignResult","pub_key_X","pub_key_Y","keys","nonceResult","nonce","modifiedPubKey","getOrSetNonce","BN","typeOfUser","keyFromPublic","y","getPublic","add","keyFromPrivate","pubNonce","finalX","getX","finalY","getY","address","generateAddressFromPubKey","upgraded","setCustomKey","privKeyHex","metadataNonce","torusKeyHex","customKeyHex","torusKey","privKey","sub","umod","curve","n","customKey","newMetadataNonce","generateMetadataParams","setMetadata","retrieveShares","indexes","verifierParams","idToken","extraParams","promiseArr","get","tmpKey","generatePrivate","pubKey","tokenCommitment","p","messageprefix","tokencommitment","temppubx","temppuby","verifieridentifier","completedRequests","promiseArrRequest","nodeSigs","encrypted","item","idtoken","nodesignatures","shareResponses","thresholdPublicKey","PublicKey","sharePromises","nodeIndexes","currentShareResponse","sort","b","Index","cmp","firstKey","Metadata","metadata","ephemPublicKey","Buffer","iv","mac","decrypt","ciphertext","Share","padStart","debug","sharesResolved","all","decryptedShares","curr","value","allCombis","privateKey","currentCombi","currentCombiShares","shares","indices","derivedPrivateKey","lagrangeInterpolation","decryptedPubKey","decryptedPubKeyX","decryptedPubKeyY","returnedKey","getNonce","getMetadata","ethAddress","generateAddressFromPrivKey","options","metadataResponse","key","setData","timestamp","Date","now","sig","sign","set_data","signature","r","nodeIndex","secret","upper","lower","mul","neg","temp","delta","invm","publicKey","encode","info","ethAddressLower","toChecksumAddress","publicKeyX","publicKeyY","getPublicAddress","isExtended","getOnly","getPostboxKeyFrom1OutOf1","privKeyBN","nonceBN"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, setAPIKey, setEmbedHost, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport createKeccakHash from 'keccak';\n\nconst log = loglevel.getLogger(\"torus.js\");\nlog.disableAll();\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nclass SomeError extends Error {\n  constructor(_ref) {\n    let {\n      errors,\n      responses,\n      predicate\n    } = _ref;\n    super(\"Unable to resolve enough promises.\");\n\n    _defineProperty(this, \"errors\", void 0);\n\n    _defineProperty(this, \"responses\", void 0);\n\n    _defineProperty(this, \"predicate\", void 0);\n\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n\n}\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  return promises.forEach((x, index) => {\n    return x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    }) // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n\n              const {\n                id,\n                error\n              } = z;\n\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n\n            return acc;\n          }, {}));\n\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => `â€¢ ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass GetOrSetNonceError extends Error {}\nconst kCombinations = (s, k) => {\n  let set = s;\n\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n\n  if (k === set.length) {\n    return [set];\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n\n  const combs = [];\n  let tailCombs = [];\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n\n  return combs;\n};\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n\n  return undefined;\n};\nconst keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(\"VerifierLookupRequest\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  })).catch(err => log.error(\"lookup request failed\", err)));\n  return Some(lookupPromises, lookupResults => {\n    const lookupShares = lookupResults.filter(x1 => x1);\n    const errorResult = thresholdSame(lookupShares.map(x2 => x2 && x2.error), ~~(endpoints.length / 2) + 1);\n    const keyResult = thresholdSame(lookupShares.map(x3 => x3 && x3.result), ~~(endpoints.length / 2) + 1);\n\n    if (keyResult || errorResult) {\n      return Promise.resolve({\n        keyResult,\n        errorResult\n      });\n    }\n\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`));\n  });\n};\nconst waitKeyLookup = (endpoints, verifier, verifierId, timeout) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n  }, timeout);\n});\nconst keyAssign = async _ref => {\n  let {\n    endpoints,\n    torusNodePubs,\n    lastPoint,\n    firstPoint,\n    verifier,\n    verifierId,\n    signerHost,\n    network\n  } = _ref;\n  let nodeNum;\n  let initialPoint;\n\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length);\n    initialPoint = nodeNum;\n  } else {\n    nodeNum = lastPoint % endpoints.length;\n  }\n\n  if (nodeNum === firstPoint) throw new Error(\"Looped through all\");\n  if (firstPoint !== undefined) initialPoint = firstPoint;\n  const data = generateJsonRPCObject(\"KeyAssign\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  });\n\n  try {\n    const signedData = await post(signerHost, data, {\n      headers: {\n        pubKeyX: torusNodePubs[nodeNum].X,\n        pubKeyY: torusNodePubs[nodeNum].Y,\n        network\n      }\n    }, {\n      useAPIKey: true\n    });\n    return await post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    });\n  } catch (error) {\n    log.error(error);\n    const acceptedErrorMsgs = [// Slow node\n    \"Timed out\", // Happens when the node is not reachable (dns issue etc)\n    \"TypeError: Failed to fetch\", \"TypeError: cancelled\", \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n    ];\n    if (acceptedErrorMsgs.includes(error.message)) return keyAssign({\n      endpoints,\n      torusNodePubs,\n      lastPoint: nodeNum + 1,\n      firstPoint: initialPoint,\n      verifier,\n      verifierId,\n      signerHost,\n      network\n    });\n    throw new Error(`Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || \"\"}`);\n  }\n};\nfunction keccak256(a) {\n  const hash = createKeccakHash(\"keccak256\").update(a).digest().toString(\"hex\");\n  return `0x${hash}`;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// of Torus nodes to handle malicious node responses\n\nclass Torus {\n  constructor() {\n    let {\n      enableOneKey = false,\n      metadataHost = \"https://metadata.tor.us\",\n      allowHost = \"https://signer.tor.us/api/allow\",\n      signerHost = \"https://signer.tor.us/api/sign\",\n      serverTimeOffset = 0,\n      network = \"mainnet\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"allowHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    _defineProperty(this, \"enableOneKey\", void 0);\n\n    _defineProperty(this, \"signerHost\", void 0);\n\n    _defineProperty(this, \"network\", void 0);\n\n    _defineProperty(this, \"ec\", void 0);\n\n    this.ec = new ec(\"secp256k1\");\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n\n  static enableLogging() {\n    let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (v) log.enableAll();else log.disableAll();\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n\n\n  async getUserTypeAndAddress(endpoints, torusNodePubs, _ref) {\n    let {\n      verifier,\n      verifierId\n    } = _ref;\n    let doesKeyAssign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n    let isNewKey = false;\n    let finalKeyResult;\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      if (!doesKeyAssign) {\n        throw new Error(\"Verifier + VerifierID has not yet been assigned\");\n      }\n\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    if (finalKeyResult) {\n      const {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n\n      try {\n        nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n        nonce = new BN(nonceResult.nonce || \"0\", 16);\n      } catch {\n        throw new GetOrSetNonceError();\n      }\n\n      if (nonceResult.typeOfUser === \"v1\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      } else if (nonceResult.typeOfUser === \"v2\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPublic({\n          x: nonceResult.pubNonce.x,\n          y: nonceResult.pubNonce.y\n        }).getPublic());\n      } else {\n        throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n      }\n\n      const finalX = modifiedPubKey.getX().toString(16);\n      const finalY = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      if (nonceResult.typeOfUser === \"v1\") return {\n        typeOfUser: nonceResult.typeOfUser,\n        nonce,\n        X: finalX,\n        Y: finalY,\n        address\n      };else if (nonceResult.typeOfUser === \"v2\") {\n        return {\n          typeOfUser: nonceResult.typeOfUser,\n          nonce,\n          pubNonce: nonceResult.pubNonce,\n          upgraded: nonceResult.upgraded,\n          X: finalX,\n          Y: finalY,\n          address\n        };\n      }\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n\n  async setCustomKey(_ref2) {\n    let {\n      privKeyHex,\n      metadataNonce,\n      torusKeyHex,\n      customKeyHex\n    } = _ref2;\n    let torusKey;\n\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16);\n    } else {\n      const privKey = new BN(privKeyHex, 16);\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n    }\n\n    const customKey = new BN(customKeyHex, 16);\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey);\n    await this.setMetadata(data);\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {\n    let extraParams = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const promiseArr = [];\n    await get(this.allowHost, {\n      headers: {\n        verifier,\n        verifier_id: verifierParams.verifier_id,\n        network: this.network\n      }\n    }, {\n      useAPIKey: true\n    });\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      }\n      */\n    // generate temporary private and public key that is used to secure receive shares\n\n    const tmpKey = generatePrivate();\n    const pubKey = getPublic(tmpKey).toString(\"hex\");\n    const pubKeyX = pubKey.slice(2, 66);\n    const pubKeyY = pubKey.slice(66);\n    const tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(endpoints[i], generateJsonRPCObject(\"CommitmentRequest\", {\n        messageprefix: \"mug00\",\n        tokencommitment: tokenCommitment.slice(2),\n        temppubx: pubKeyX,\n        temppuby: pubKeyY,\n        verifieridentifier: verifier\n      })).catch(err => {\n        log.error(\"commitment\", err);\n      });\n      promiseArr.push(p);\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n\n\n    return Some(promiseArr, resultArr => {\n      const completedRequests = resultArr.filter(x => {\n        if (!x || typeof x !== \"object\") {\n          return false;\n        }\n\n        if (x.error) {\n          return false;\n        }\n\n        return true;\n      });\n\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr);\n      }\n\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`));\n    }).then(responses => {\n      const promiseArrRequest = [];\n      const nodeSigs = [];\n\n      for (let i = 0; i < responses.length; i += 1) {\n        if (responses[i]) nodeSigs.push(responses[i].result);\n      }\n\n      for (let i = 0; i < endpoints.length; i += 1) {\n        // eslint-disable-next-line promise/no-nesting\n        const p = post(endpoints[i], generateJsonRPCObject(\"ShareRequest\", {\n          encrypted: \"yes\",\n          item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n            idtoken: idToken,\n            nodesignatures: nodeSigs,\n            verifieridentifier: verifier\n          }, extraParams)]\n        })).catch(err => log.error(\"share req\", err));\n        promiseArrRequest.push(p);\n      }\n\n      return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n        /*\n            ShareRequestResult struct {\n              Keys []KeyAssignment\n            }\n                    / KeyAssignmentPublic -\n            type KeyAssignmentPublic struct {\n              Index     big.Int\n              PublicKey common.Point\n              Threshold int\n              Verifiers map[string][]string // Verifier => VerifierID\n            }\n                   // KeyAssignment -\n            type KeyAssignment struct {\n              KeyAssignmentPublic\n              Share big.Int // Or Si\n            }\n          */\n        // check if threshold number of nodes have returned the same user public key\n        const completedRequests = shareResponses.filter(x => x);\n        const thresholdPublicKey = thresholdSame(shareResponses.map(x => x && x.result && x.result.keys[0].PublicKey), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n        // this is matched against the user public key to ensure that shares are consistent\n\n        if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n          const sharePromises = [];\n          const nodeIndexes = [];\n\n          for (let i = 0; i < shareResponses.length; i += 1) {\n            var _currentShareResponse, _currentShareResponse2;\n\n            const currentShareResponse = shareResponses[i];\n\n            if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {\n              currentShareResponse.result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)));\n              const firstKey = currentShareResponse.result.keys[0];\n\n              if (firstKey.Metadata) {\n                const metadata = {\n                  ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, \"hex\"),\n                  iv: Buffer.from(firstKey.Metadata.iv, \"hex\"),\n                  mac: Buffer.from(firstKey.Metadata.mac, \"hex\") // mode: Buffer.from(firstKey.Metadata.mode, \"hex\"),\n\n                };\n                sharePromises.push( // eslint-disable-next-line promise/no-nesting\n                decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                  ciphertext: Buffer.from(Buffer.from(firstKey.Share, \"base64\").toString(\"binary\").padStart(64, \"0\"), \"hex\")\n                })).catch(err => log.debug(\"share decryption\", err)));\n              } else {\n                sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, \"0\"), \"hex\")));\n              }\n            } else {\n              sharePromises.push(Promise.resolve(undefined));\n            }\n\n            nodeIndexes.push(new BN(indexes[i], 16));\n          }\n\n          const sharesResolved = await Promise.all(sharePromises);\n          if (sharedState.resolved) return undefined;\n          const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n            if (curr) acc.push({\n              index: nodeIndexes[index],\n              value: new BN(curr)\n            });\n            return acc;\n          }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n          const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n          let privateKey = null;\n\n          for (let j = 0; j < allCombis.length; j += 1) {\n            const currentCombi = allCombis[j];\n            const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index));\n            const shares = currentCombiShares.map(x => x.value);\n            const indices = currentCombiShares.map(x => x.index);\n            const derivedPrivateKey = this.lagrangeInterpolation(shares, indices);\n            if (!derivedPrivateKey) continue;\n            const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n            const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n            const decryptedPubKeyY = decryptedPubKey.slice(66);\n\n            if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n              privateKey = derivedPrivateKey;\n              break;\n            }\n          }\n\n          if (privateKey === undefined || privateKey === null) {\n            throw new Error(\"could not derive private key\");\n          }\n\n          return privateKey;\n        }\n\n        throw new Error(\"invalid\");\n      });\n    }).then(async returnedKey => {\n      let privateKey = returnedKey;\n      if (!privateKey) throw new Error(\"Invalid private key returned\");\n      const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n      const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n      const decryptedPubKeyY = decryptedPubKey.slice(66);\n      let metadataNonce;\n\n      if (this.enableOneKey) {\n        const {\n          nonce\n        } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n        metadataNonce = new BN(nonce || \"0\", 16);\n      } else {\n        metadataNonce = await this.getMetadata({\n          pub_key_X: decryptedPubKeyX,\n          pub_key_Y: decryptedPubKeyY\n        });\n      }\n\n      log.debug(\"> torus.js/retrieveShares\", {\n        privKey: privateKey.toString(16),\n        metadataNonce: metadataNonce.toString(16)\n      });\n      privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n);\n      const ethAddress = this.generateAddressFromPrivKey(privateKey);\n      log.debug(\"> torus.js/retrieveShares\", {\n        ethAddress,\n        privKey: privateKey.toString(16)\n      }); // return reconstructed private key and ethereum address\n\n      return {\n        ethAddress,\n        privKey: privateKey.toString(\"hex\", 64),\n        metadataNonce\n      };\n    });\n  }\n\n  async getMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, {\n        useAPIKey: true\n      });\n\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0);\n      }\n\n      return new BN(metadataResponse.message, 16); // nonce\n    } catch (error) {\n      log.error(\"get metadata error\", error);\n      return new BN(0);\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64));\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    };\n  }\n\n  async setMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, {\n        useAPIKey: true\n      });\n      return metadataResponse.message; // IPFS hash\n    } catch (error) {\n      log.error(\"set metadata error\", error);\n      return \"\";\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null;\n    }\n\n    let secret = new BN(0);\n\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1);\n      let lower = new BN(1);\n\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg());\n          upper = upper.umod(this.ec.curve.n);\n          let temp = nodeIndex[i].sub(nodeIndex[j]);\n          temp = temp.umod(this.ec.curve.n);\n          lower = lower.mul(temp).umod(this.ec.curve.n);\n        }\n      }\n\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n      secret = secret.add(delta);\n    }\n\n    return secret.umod(this.ec.curve.n);\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(publicKey, \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({\n      x: publicKeyX.toString(\"hex\", 64),\n      y: publicKeyY.toString(\"hex\", 64)\n    });\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(key.getPublic().encode(\"hex\", false), \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n\n\n  async getPublicAddress(endpoints, torusNodePubs, _ref3) {\n    let {\n      verifier,\n      verifierId\n    } = _ref3;\n    let isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    log.debug(\"> torus.js/getPublicAddress\", {\n      endpoints,\n      torusNodePubs,\n      verifier,\n      verifierId,\n      isExtended\n    });\n    let finalKeyResult;\n    let isNewKey = false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier not supported\")) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n    } else if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    log.debug(\"> torus.js/getPublicAddress\", {\n      finalKeyResult,\n      isNewKey\n    });\n\n    if (finalKeyResult) {\n      var _nonce;\n\n      let {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n      let typeOfUser;\n      let pubNonce;\n\n      if (this.enableOneKey) {\n        try {\n          nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n          nonce = new BN(nonceResult.nonce || \"0\", 16);\n          typeOfUser = nonceResult.typeOfUser;\n        } catch {\n          throw new GetOrSetNonceError();\n        }\n\n        if (nonceResult.typeOfUser === \"v1\") {\n          modifiedPubKey = this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        } else if (nonceResult.typeOfUser === \"v2\") {\n          if (nonceResult.upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic();\n          } else {\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic().add(this.ec.keyFromPublic({\n              x: nonceResult.pubNonce.x,\n              y: nonceResult.pubNonce.y\n            }).getPublic());\n            pubNonce = nonceResult.pubNonce;\n          }\n        } else {\n          throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n        }\n      } else {\n        typeOfUser = \"v1\";\n        nonce = await this.getMetadata({\n          pub_key_X: X,\n          pub_key_Y: Y\n        });\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      }\n\n      X = modifiedPubKey.getX().toString(16);\n      Y = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      log.debug(\"> torus.js/getPublicAddress\", {\n        X,\n        Y,\n        address,\n        typeOfUser,\n        nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n        pubNonce\n      });\n      if (!isExtended) return address;\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce\n      };\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n\n  async getOrSetNonce(X, Y, privKey) {\n    let getOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let data;\n    const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey);\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: {\n          data: msg\n        }\n      };\n    }\n\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true);\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16);\n    const nonceBN = new BN(nonce, 16);\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString(\"hex\");\n  }\n\n}\n\nexport { GetOrSetNonceError, Torus as default, kCombinations, keccak256, keyAssign, keyLookup, thresholdSame, waitKeyLookup };\n//# sourceMappingURL=torusUtils.esm.js.map\n"]},"metadata":{},"sourceType":"module"}