{"ast":null,"code":"import eachSeries from 'async/eachSeries';\nimport map from 'async/map';\nimport BaseProvider from './base-provider';\nimport { ProviderEngineError, ProviderEngineErrorCode } from './errors/provider-engine-error';\nimport BlockTracker from './util/block-tracker';\nimport Stoplight from './util/stoplight';\nimport { createPayload } from './util/create-payload';\nexport default class Web3ProviderEngine extends BaseProvider {\n  constructor(opts) {\n    super();\n    this._pollForBlocks = true;\n    this._running = false;\n    this.setMaxListeners(30);\n    // parse options\n    opts = opts || {};\n    // block polling\n    const directProvider = {\n      sendAsync: this._handleAsync.bind(this)\n    };\n    if (opts.disableBlockTracking === true) {\n      this._pollForBlocks = false;\n    }\n    const blockTrackerProvider = opts.blockTrackerProvider || directProvider;\n    this._blockTracker = new BlockTracker({\n      provider: blockTrackerProvider,\n      blockTracker: opts.blockTracker,\n      pollingInterval: opts.pollingInterval || 4000\n    });\n    this._blockTracker.on('block', this._setCurrentBlock.bind(this));\n    this._blockTracker.on('sync', this.emit.bind(this, 'sync'));\n    this._blockTracker.on('rawBlock', this.emit.bind(this, 'rawBlock'));\n    this._blockTracker.on('latest', this.emit.bind(this, 'latest'));\n    // Handle errors instead of re-emitting, since they will throw otherwise\n    this._blockTracker.on('error', error => {\n      // Ignore errors from the block tracker unless debug is enabled\n      if (opts.debug) {\n        // eslint-disable-next-line no-console\n        console.log('DEBUG: ' + error.message);\n      }\n    });\n    // set initialization blocker\n    this._ready = new Stoplight();\n    this._providers = [];\n  }\n  isRunning() {\n    return this._running;\n  }\n  start() {\n    // trigger start\n    this._ready.go();\n    if (this._pollForBlocks) {\n      // start tracking blocks\n      this._blockTracker.start();\n    }\n    // update state\n    this._running = true;\n    // signal that we started\n    this.emit('start');\n  }\n  stop() {\n    // stop block tracking\n    this._blockTracker.stop();\n    // update state\n    this._running = false;\n    // signal that we stopped\n    this.emit('stop');\n  }\n  addProvider(source, index) {\n    if (typeof index === 'number') {\n      this._providers.splice(index, 0, source);\n    } else {\n      this._providers.push(source);\n    }\n    source.setEngine(this);\n  }\n  removeProvider(source) {\n    const index = this._providers.indexOf(source);\n    if (index < 0) throw new Error('Provider not found.');\n    this._providers.splice(index, 1);\n  }\n  send(method, params) {\n    // Wrap base class with Stoplight\n    return new Promise((fulfill, reject) => {\n      this._ready.await(() => {\n        super.send(method, params).then(fulfill, reject);\n      });\n    });\n  }\n  sendAsync(payload, cb) {\n    // Wrap base class with Stoplight\n    this._ready.await(() => {\n      if (Array.isArray(payload)) {\n        // handle batch\n        map(payload, this._handleAsync.bind(this), cb);\n      } else {\n        // handle single\n        this._handleAsync(payload, cb);\n      }\n    });\n  }\n  // Actually perform the request\n  sendPayload(payload) {\n    return new Promise((fulfill, reject) => {\n      let currentProvider = -1;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      let result = null;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      let error = null;\n      // Stack of subprovider next callbacks\n      const stack = [];\n      const next = callback => {\n        currentProvider += 1;\n        if (callback) {\n          // Insert in front since eachSeries traverses from front\n          stack.unshift(callback);\n        }\n        // Bubbled down as far as we could go, and the request wasn't\n        // handled. Return an error.\n        if (currentProvider >= this._providers.length) {\n          // tslint:disable-next-line: max-line-length\n          const msg = `Request for method \"${payload.method}\" not handled by any subprovider.`;\n          end(new ProviderEngineError(msg, ProviderEngineErrorCode.UnhandledRequest));\n          return;\n        }\n        // Handle request in next subprovider\n        try {\n          const provider = this._providers[currentProvider];\n          provider.handleRequest(payload, next, end);\n        } catch (e) {\n          end(e);\n        }\n      };\n      const notifySubprovider = (fn, callback) => {\n        if (fn) {\n          fn(error, result, callback);\n        } else {\n          callback();\n        }\n      };\n      const end = (e, r) => {\n        error = e;\n        result = r;\n        // Call any callbacks from subproviders\n        eachSeries(stack, notifySubprovider).then(() => {\n          // Reconstruct JSONRPCResponse\n          const resultObj = {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result\n          };\n          // Complete promise\n          if (error) {\n            reject(error);\n          } else {\n            fulfill(resultObj);\n          }\n        });\n      };\n      // Call next() to kick things off\n      next();\n    });\n  }\n  _setCurrentBlock(bufferBlock) {\n    this.currentBlock = bufferBlock;\n    this.emit('block', bufferBlock);\n  }\n  _getBlockByNumber(blockNumber, cb) {\n    const req = createPayload({\n      method: 'eth_getBlockByNumber',\n      params: [blockNumber, false],\n      skipCache: true\n    });\n    this._handleAsync(req, (err, res) => {\n      if (err) return cb(err);\n      return cb(null, res.result);\n    });\n  }\n  _handleAsync(payload, finished) {\n    let currentProvider = -1;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const result = null;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const error = null;\n    const stack = [];\n    const next = after => {\n      currentProvider += 1;\n      stack.unshift(after);\n      // Bubbled down as far as we could go, and the request wasn't\n      // handled. Return an error.\n      if (currentProvider >= this._providers.length) {\n        end(new Error(`Request for method \"${payload.method}\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.`));\n      } else {\n        try {\n          const provider = this._providers[currentProvider];\n          provider.handleRequest(payload, next, end);\n        } catch (e) {\n          end(e);\n        }\n      }\n    };\n    const end = (error, result) => {\n      eachSeries(stack, (fn, callback) => {\n        if (fn) {\n          fn(error, result, callback);\n        } else {\n          callback();\n        }\n      }, () => {\n        const resultObj = {\n          id: payload.id,\n          jsonrpc: payload.jsonrpc,\n          result: result,\n          error: null\n        };\n        if (error != null) {\n          resultObj.error = {\n            message: error.stack || error.message || error,\n            code: -32000\n          };\n          // respond with both error formats\n          finished(error, resultObj);\n        } else {\n          finished(null, resultObj);\n        }\n      });\n    };\n    next();\n  }\n}","map":{"version":3,"names":["eachSeries","map","BaseProvider","ProviderEngineError","ProviderEngineErrorCode","BlockTracker","Stoplight","createPayload","Web3ProviderEngine","constructor","opts","_pollForBlocks","_running","setMaxListeners","directProvider","sendAsync","_handleAsync","bind","disableBlockTracking","blockTrackerProvider","_blockTracker","provider","blockTracker","pollingInterval","on","_setCurrentBlock","emit","error","debug","console","log","message","_ready","_providers","isRunning","start","go","stop","addProvider","source","index","splice","push","setEngine","removeProvider","indexOf","Error","send","method","params","Promise","fulfill","reject","await","then","payload","cb","Array","isArray","sendPayload","currentProvider","result","stack","next","callback","unshift","length","msg","end","UnhandledRequest","handleRequest","e","notifySubprovider","fn","r","resultObj","id","jsonrpc","bufferBlock","currentBlock","_getBlockByNumber","blockNumber","req","skipCache","err","res","finished","after","code"],"sources":["/Users/charvai/Desktop/template/node_modules/@bitski/provider-engine/dist/modules/provider-engine.js"],"sourcesContent":["import eachSeries from 'async/eachSeries';\nimport map from 'async/map';\nimport BaseProvider from './base-provider';\nimport { ProviderEngineError, ProviderEngineErrorCode } from './errors/provider-engine-error';\nimport BlockTracker from './util/block-tracker';\nimport Stoplight from './util/stoplight';\nimport { createPayload } from './util/create-payload';\nexport default class Web3ProviderEngine extends BaseProvider {\n    constructor(opts) {\n        super();\n        this._pollForBlocks = true;\n        this._running = false;\n        this.setMaxListeners(30);\n        // parse options\n        opts = opts || {};\n        // block polling\n        const directProvider = { sendAsync: this._handleAsync.bind(this) };\n        if (opts.disableBlockTracking === true) {\n            this._pollForBlocks = false;\n        }\n        const blockTrackerProvider = opts.blockTrackerProvider || directProvider;\n        this._blockTracker = new BlockTracker({\n            provider: blockTrackerProvider,\n            blockTracker: opts.blockTracker,\n            pollingInterval: opts.pollingInterval || 4000,\n        });\n        this._blockTracker.on('block', this._setCurrentBlock.bind(this));\n        this._blockTracker.on('sync', this.emit.bind(this, 'sync'));\n        this._blockTracker.on('rawBlock', this.emit.bind(this, 'rawBlock'));\n        this._blockTracker.on('latest', this.emit.bind(this, 'latest'));\n        // Handle errors instead of re-emitting, since they will throw otherwise\n        this._blockTracker.on('error', (error) => {\n            // Ignore errors from the block tracker unless debug is enabled\n            if (opts.debug) {\n                // eslint-disable-next-line no-console\n                console.log('DEBUG: ' + error.message);\n            }\n        });\n        // set initialization blocker\n        this._ready = new Stoplight();\n        this._providers = [];\n    }\n    isRunning() {\n        return this._running;\n    }\n    start() {\n        // trigger start\n        this._ready.go();\n        if (this._pollForBlocks) {\n            // start tracking blocks\n            this._blockTracker.start();\n        }\n        // update state\n        this._running = true;\n        // signal that we started\n        this.emit('start');\n    }\n    stop() {\n        // stop block tracking\n        this._blockTracker.stop();\n        // update state\n        this._running = false;\n        // signal that we stopped\n        this.emit('stop');\n    }\n    addProvider(source, index) {\n        if (typeof index === 'number') {\n            this._providers.splice(index, 0, source);\n        }\n        else {\n            this._providers.push(source);\n        }\n        source.setEngine(this);\n    }\n    removeProvider(source) {\n        const index = this._providers.indexOf(source);\n        if (index < 0)\n            throw new Error('Provider not found.');\n        this._providers.splice(index, 1);\n    }\n    send(method, params) {\n        // Wrap base class with Stoplight\n        return new Promise((fulfill, reject) => {\n            this._ready.await(() => {\n                super.send(method, params).then(fulfill, reject);\n            });\n        });\n    }\n    sendAsync(payload, cb) {\n        // Wrap base class with Stoplight\n        this._ready.await(() => {\n            if (Array.isArray(payload)) {\n                // handle batch\n                map(payload, this._handleAsync.bind(this), cb);\n            }\n            else {\n                // handle single\n                this._handleAsync(payload, cb);\n            }\n        });\n    }\n    // Actually perform the request\n    sendPayload(payload) {\n        return new Promise((fulfill, reject) => {\n            let currentProvider = -1;\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            let result = null;\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            let error = null;\n            // Stack of subprovider next callbacks\n            const stack = [];\n            const next = (callback) => {\n                currentProvider += 1;\n                if (callback) {\n                    // Insert in front since eachSeries traverses from front\n                    stack.unshift(callback);\n                }\n                // Bubbled down as far as we could go, and the request wasn't\n                // handled. Return an error.\n                if (currentProvider >= this._providers.length) {\n                    // tslint:disable-next-line: max-line-length\n                    const msg = `Request for method \"${payload.method}\" not handled by any subprovider.`;\n                    end(new ProviderEngineError(msg, ProviderEngineErrorCode.UnhandledRequest));\n                    return;\n                }\n                // Handle request in next subprovider\n                try {\n                    const provider = this._providers[currentProvider];\n                    provider.handleRequest(payload, next, end);\n                }\n                catch (e) {\n                    end(e);\n                }\n            };\n            const notifySubprovider = (fn, callback) => {\n                if (fn) {\n                    fn(error, result, callback);\n                }\n                else {\n                    callback();\n                }\n            };\n            const end = (e, r) => {\n                error = e;\n                result = r;\n                // Call any callbacks from subproviders\n                eachSeries(stack, notifySubprovider).then(() => {\n                    // Reconstruct JSONRPCResponse\n                    const resultObj = {\n                        id: payload.id,\n                        jsonrpc: payload.jsonrpc,\n                        result,\n                    };\n                    // Complete promise\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        fulfill(resultObj);\n                    }\n                });\n            };\n            // Call next() to kick things off\n            next();\n        });\n    }\n    _setCurrentBlock(bufferBlock) {\n        this.currentBlock = bufferBlock;\n        this.emit('block', bufferBlock);\n    }\n    _getBlockByNumber(blockNumber, cb) {\n        const req = createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true });\n        this._handleAsync(req, (err, res) => {\n            if (err)\n                return cb(err);\n            return cb(null, res.result);\n        });\n    }\n    _handleAsync(payload, finished) {\n        let currentProvider = -1;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const result = null;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const error = null;\n        const stack = [];\n        const next = (after) => {\n            currentProvider += 1;\n            stack.unshift(after);\n            // Bubbled down as far as we could go, and the request wasn't\n            // handled. Return an error.\n            if (currentProvider >= this._providers.length) {\n                end(new Error(`Request for method \"${payload.method}\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.`));\n            }\n            else {\n                try {\n                    const provider = this._providers[currentProvider];\n                    provider.handleRequest(payload, next, end);\n                }\n                catch (e) {\n                    end(e);\n                }\n            }\n        };\n        const end = (error, result) => {\n            eachSeries(stack, (fn, callback) => {\n                if (fn) {\n                    fn(error, result, callback);\n                }\n                else {\n                    callback();\n                }\n            }, () => {\n                const resultObj = {\n                    id: payload.id,\n                    jsonrpc: payload.jsonrpc,\n                    result: result,\n                    error: null,\n                };\n                if (error != null) {\n                    resultObj.error = {\n                        message: error.stack || error.message || error,\n                        code: -32000,\n                    };\n                    // respond with both error formats\n                    finished(error, resultObj);\n                }\n                else {\n                    finished(null, resultObj);\n                }\n            });\n        };\n        next();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}