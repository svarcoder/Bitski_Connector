{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = retry;\nvar _noop = require('lodash/noop');\nvar _noop2 = _interopRequireDefault(_noop);\nvar _constant = require('lodash/constant');\nvar _constant2 = _interopRequireDefault(_constant);\nvar _wrapAsync = require('./internal/wrapAsync');\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n  var DEFAULT_TIMES = 5;\n  var DEFAULT_INTERVAL = 0;\n  var options = {\n    times: DEFAULT_TIMES,\n    intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)\n  };\n  function parseTimes(acc, t) {\n    if (typeof t === 'object') {\n      acc.times = +t.times || DEFAULT_TIMES;\n      acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);\n      acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n      acc.times = +t || DEFAULT_TIMES;\n    } else {\n      throw new Error(\"Invalid arguments for async.retry\");\n    }\n  }\n  if (arguments.length < 3 && typeof opts === 'function') {\n    callback = task || _noop2.default;\n    task = opts;\n  } else {\n    parseTimes(options, opts);\n    callback = callback || _noop2.default;\n  }\n  if (typeof task !== 'function') {\n    throw new Error(\"Invalid arguments for async.retry\");\n  }\n  var _task = (0, _wrapAsync2.default)(task);\n  var attempt = 1;\n  function retryAttempt() {\n    _task(function (err) {\n      if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n        setTimeout(retryAttempt, options.intervalFunc(attempt));\n      } else {\n        callback.apply(null, arguments);\n      }\n    });\n  }\n  retryAttempt();\n}\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","retry","_noop","require","_noop2","_interopRequireDefault","_constant","_constant2","_wrapAsync","_wrapAsync2","obj","__esModule","opts","task","callback","DEFAULT_TIMES","DEFAULT_INTERVAL","options","times","intervalFunc","parseTimes","acc","t","interval","errorFilter","Error","arguments","length","_task","attempt","retryAttempt","err","setTimeout","apply","module"],"sources":["/Users/charvai/Desktop/template/node_modules/async/retry.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _constant = require('lodash/constant');\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || _noop2.default;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || _noop2.default;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = (0, _wrapAsync2.default)(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\nmodule.exports = exports['default'];"],"mappings":"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"},"metadata":{},"sourceType":"script"}