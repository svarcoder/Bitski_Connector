{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _DefaultNetworkStore_networks;\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport { ProviderError } from 'bitski-provider/lib/errors/provider-error';\nimport { BinanceSmartChain, BinanceSmartChainTestnet, Mainnet, Goerli, Polygon, Mumbai } from 'bitski-provider/lib/network';\nimport { createResponse } from './-private/utils/jsonrpc';\nimport { toHex } from './-private/utils/numbers';\nclass DefaultNetworkStore {\n  constructor() {\n    _DefaultNetworkStore_networks.set(this, new Map([['0x1', Mainnet], ['0x5', Goerli], ['0x89', Polygon], ['0x13881', Mumbai], ['0x38', BinanceSmartChain], ['0x61', BinanceSmartChainTestnet]]));\n  }\n  async get(chainId) {\n    return __classPrivateFieldGet(this, _DefaultNetworkStore_networks, \"f\").get(chainId);\n  }\n  async add(chainDetails) {\n    const chainId = parseInt(chainDetails.chainId, 16);\n    const rpcUrl = chainDetails.rpcUrls[0];\n    __classPrivateFieldGet(this, _DefaultNetworkStore_networks, \"f\").set(chainDetails.chainId, {\n      chainId,\n      rpcUrl\n    });\n  }\n}\n_DefaultNetworkStore_networks = new WeakMap();\nexport class BitskiProvider extends SafeEventEmitter {\n  constructor(sdkPromise, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let\n    // Network and network provider store allows multiple instances of\n    // BitskiProvider to share state. This is used by the extension so we only\n    // have one provider per-chain, but can have different selected providers\n    // per page.\n    networkStore = arguments.length > 3 ? arguments[3] : undefined;\n    let networkProviderStore = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Map();\n    super();\n    this.subproviders = [];\n    this.subscriptionMap = new Map();\n    this.sdkPromise = sdkPromise;\n    this.providerOptions = options;\n    this.networkStore = networkStore !== null && networkStore !== void 0 ? networkStore : new DefaultNetworkStore();\n    this.networkProviderStore = networkProviderStore;\n    this.currentProviderPromise = this.setupChain(network);\n  }\n  get currentBlock() {\n    var _a;\n    return (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.currentBlock;\n  }\n  supportsSubscriptions() {\n    return !this.providerOptions.disableBlockTracking;\n  }\n  async subscribe(subscribeMethod, subscriptionMethod, parameters) {\n    const provider = await this.currentProviderPromise;\n    const subscriptionId = await provider.subscribe(subscribeMethod, subscriptionMethod, parameters);\n    this.subscriptionMap.set(subscriptionId, provider);\n    return subscriptionId;\n  }\n  async unsubscribe(subscriptionId, unsubscribeMethod) {\n    var _a;\n    const provider = this.subscriptionMap.get(subscriptionId);\n    const result = await ((_a = provider === null || provider === void 0 ? void 0 : provider.unsubscribe(subscriptionId, unsubscribeMethod)) !== null && _a !== void 0 ? _a : false);\n    if (result) {\n      this.subscriptionMap.delete(subscriptionId);\n    }\n    return result;\n  }\n  isRunning() {\n    var _a, _b;\n    return (_b = (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.isRunning()) !== null && _b !== void 0 ? _b : false;\n  }\n  start() {\n    // Wait for the provider promise so we're loaded and bootstrapped\n    this.currentProviderPromise.then(() => {\n      this.networkProviderStore.forEach(p => p.start());\n    });\n  }\n  stop() {\n    this.currentProviderPromise.then(() => {\n      this.networkProviderStore.forEach(p => p.stop());\n    });\n  }\n  addProvider(source, index) {\n    this.currentProviderPromise.then(() => {\n      this.networkProviderStore.forEach(p => p.addProvider(source, index));\n    });\n    // Save the subprovider to add to new chains if we ever switch chains\n    this.subproviders.push([source, index]);\n  }\n  removeProvider(source) {\n    this.currentProviderPromise.then(() => {\n      this.networkProviderStore.forEach(p => p.removeProvider(source));\n    });\n    // Remove from saved subproviders\n    const index = this.subproviders.findIndex(s => s[0] === source);\n    this.subproviders.splice(index, 1);\n  }\n  async request(_ref) {\n    let {\n      method,\n      params = []\n    } = _ref;\n    if (method === 'wallet_addEthereumChain') {\n      return this.addChain(params[0]);\n    } else if (method === 'wallet_switchEthereumChain') {\n      return this.switchChain(params[0]);\n    } else if (method === 'eth_chainId') {\n      await this.currentProviderPromise;\n      return this.currentChainId;\n    } else {\n      const provider = await this.currentProviderPromise;\n      return provider.send(method, params);\n    }\n  }\n  send(methodOrPayload, paramsOrCallback) {\n    if (typeof methodOrPayload !== 'string' && !Array.isArray(paramsOrCallback)) {\n      return this.sendAsync(methodOrPayload, paramsOrCallback);\n    }\n    return this.request({\n      method: methodOrPayload,\n      params: paramsOrCallback\n    }).then(result => {\n      return createResponse(undefined, result);\n    }).catch(err => {\n      return createResponse(err);\n    });\n  }\n  /**\n   * @deprecated Please use `.request` instead.\n   * @param payload - Request Payload\n   */\n  sendAsync(payload, callback) {\n    this.request(payload).then(response => {\n      callback(null, createResponse(undefined, response));\n    }).catch(err => {\n      callback(err);\n    });\n  }\n  async addChain(chainDetails) {\n    var _a;\n    if (await this.networkStore.get(chainDetails.chainId)) {\n      throw new Error('Chain already exists');\n    }\n    if (!(((_a = chainDetails.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) > 0)) {\n      throw new Error('RPC url is required when adding a chain');\n    }\n    await this.networkStore.add(chainDetails);\n    return null;\n  }\n  async switchChain(chainDetails) {\n    const network = await this.networkStore.get(chainDetails.chainId);\n    if (!network) {\n      throw new ProviderError('Chain does not exist', 4902);\n    }\n    this.currentProviderPromise = this.setupChain(network);\n    this.emit('chainChanged');\n    return null;\n  }\n  async setupChain(network) {\n    let provider = this.networkProviderStore.get(network);\n    if (!provider) {\n      const sdk = await this.sdkPromise;\n      if (!sdk) {\n        throw new Error('Bitski SDK not available');\n      }\n      provider = sdk.createProvider(network, this.providerOptions);\n      // Add all previously added providers to the new chain\n      for (const [subprovider, index] of this.subproviders) {\n        provider.addProvider(subprovider, index);\n      }\n      // Override provider emit so it emits directly to the wrapper/loader\n      provider.emit = this.emit.bind(this);\n      this.networkProviderStore.set(network, provider);\n      provider.start();\n    }\n    // Set current provider so we can access it for non-async values\n    this.currentProvider = provider;\n    this.currentChainId = toHex(network.chainId);\n    return provider;\n  }\n}","map":{"version":3,"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","_DefaultNetworkStore_networks","SafeEventEmitter","ProviderError","BinanceSmartChain","BinanceSmartChainTestnet","Mainnet","Goerli","Polygon","Mumbai","createResponse","toHex","DefaultNetworkStore","constructor","set","Map","chainId","add","chainDetails","parseInt","rpcUrl","rpcUrls","WeakMap","BitskiProvider","sdkPromise","network","options","networkStore","networkProviderStore","subproviders","subscriptionMap","providerOptions","currentProviderPromise","setupChain","currentBlock","_a","currentProvider","supportsSubscriptions","disableBlockTracking","subscribe","subscribeMethod","subscriptionMethod","parameters","provider","subscriptionId","unsubscribe","unsubscribeMethod","result","delete","isRunning","_b","start","then","forEach","p","stop","addProvider","source","index","push","removeProvider","findIndex","s","splice","request","method","params","addChain","switchChain","currentChainId","send","methodOrPayload","paramsOrCallback","Array","isArray","sendAsync","undefined","catch","err","payload","callback","response","Error","length","emit","sdk","createProvider","subprovider","bind"],"sources":["/Users/charvai/Desktop/template/node_modules/bitski/dist/esm/provider.js"],"sourcesContent":["var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _DefaultNetworkStore_networks;\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport { ProviderError } from 'bitski-provider/lib/errors/provider-error';\nimport { BinanceSmartChain, BinanceSmartChainTestnet, Mainnet, Goerli, Polygon, Mumbai, } from 'bitski-provider/lib/network';\nimport { createResponse } from './-private/utils/jsonrpc';\nimport { toHex } from './-private/utils/numbers';\nclass DefaultNetworkStore {\n    constructor() {\n        _DefaultNetworkStore_networks.set(this, new Map([\n            ['0x1', Mainnet],\n            ['0x5', Goerli],\n            ['0x89', Polygon],\n            ['0x13881', Mumbai],\n            ['0x38', BinanceSmartChain],\n            ['0x61', BinanceSmartChainTestnet],\n        ]));\n    }\n    async get(chainId) {\n        return __classPrivateFieldGet(this, _DefaultNetworkStore_networks, \"f\").get(chainId);\n    }\n    async add(chainDetails) {\n        const chainId = parseInt(chainDetails.chainId, 16);\n        const rpcUrl = chainDetails.rpcUrls[0];\n        __classPrivateFieldGet(this, _DefaultNetworkStore_networks, \"f\").set(chainDetails.chainId, {\n            chainId,\n            rpcUrl,\n        });\n    }\n}\n_DefaultNetworkStore_networks = new WeakMap();\nexport class BitskiProvider extends SafeEventEmitter {\n    constructor(sdkPromise, network, options = {}, \n    // Network and network provider store allows multiple instances of\n    // BitskiProvider to share state. This is used by the extension so we only\n    // have one provider per-chain, but can have different selected providers\n    // per page.\n    networkStore, networkProviderStore = new Map()) {\n        super();\n        this.subproviders = [];\n        this.subscriptionMap = new Map();\n        this.sdkPromise = sdkPromise;\n        this.providerOptions = options;\n        this.networkStore = networkStore !== null && networkStore !== void 0 ? networkStore : new DefaultNetworkStore();\n        this.networkProviderStore = networkProviderStore;\n        this.currentProviderPromise = this.setupChain(network);\n    }\n    get currentBlock() {\n        var _a;\n        return (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.currentBlock;\n    }\n    supportsSubscriptions() {\n        return !this.providerOptions.disableBlockTracking;\n    }\n    async subscribe(subscribeMethod, subscriptionMethod, parameters) {\n        const provider = await this.currentProviderPromise;\n        const subscriptionId = await provider.subscribe(subscribeMethod, subscriptionMethod, parameters);\n        this.subscriptionMap.set(subscriptionId, provider);\n        return subscriptionId;\n    }\n    async unsubscribe(subscriptionId, unsubscribeMethod) {\n        var _a;\n        const provider = this.subscriptionMap.get(subscriptionId);\n        const result = await ((_a = provider === null || provider === void 0 ? void 0 : provider.unsubscribe(subscriptionId, unsubscribeMethod)) !== null && _a !== void 0 ? _a : false);\n        if (result) {\n            this.subscriptionMap.delete(subscriptionId);\n        }\n        return result;\n    }\n    isRunning() {\n        var _a, _b;\n        return (_b = (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.isRunning()) !== null && _b !== void 0 ? _b : false;\n    }\n    start() {\n        // Wait for the provider promise so we're loaded and bootstrapped\n        this.currentProviderPromise.then(() => {\n            this.networkProviderStore.forEach((p) => p.start());\n        });\n    }\n    stop() {\n        this.currentProviderPromise.then(() => {\n            this.networkProviderStore.forEach((p) => p.stop());\n        });\n    }\n    addProvider(source, index) {\n        this.currentProviderPromise.then(() => {\n            this.networkProviderStore.forEach((p) => p.addProvider(source, index));\n        });\n        // Save the subprovider to add to new chains if we ever switch chains\n        this.subproviders.push([source, index]);\n    }\n    removeProvider(source) {\n        this.currentProviderPromise.then(() => {\n            this.networkProviderStore.forEach((p) => p.removeProvider(source));\n        });\n        // Remove from saved subproviders\n        const index = this.subproviders.findIndex((s) => s[0] === source);\n        this.subproviders.splice(index, 1);\n    }\n    async request({ method, params = [] }) {\n        if (method === 'wallet_addEthereumChain') {\n            return this.addChain(params[0]);\n        }\n        else if (method === 'wallet_switchEthereumChain') {\n            return this.switchChain(params[0]);\n        }\n        else if (method === 'eth_chainId') {\n            await this.currentProviderPromise;\n            return this.currentChainId;\n        }\n        else {\n            const provider = await this.currentProviderPromise;\n            return provider.send(method, params);\n        }\n    }\n    send(methodOrPayload, paramsOrCallback) {\n        if (typeof methodOrPayload !== 'string' && !Array.isArray(paramsOrCallback)) {\n            return this.sendAsync(methodOrPayload, paramsOrCallback);\n        }\n        return this.request({ method: methodOrPayload, params: paramsOrCallback })\n            .then((result) => {\n            return createResponse(undefined, result);\n        })\n            .catch((err) => {\n            return createResponse(err);\n        });\n    }\n    /**\n     * @deprecated Please use `.request` instead.\n     * @param payload - Request Payload\n     */\n    sendAsync(payload, callback) {\n        this.request(payload)\n            .then((response) => {\n            callback(null, createResponse(undefined, response));\n        })\n            .catch((err) => {\n            callback(err);\n        });\n    }\n    async addChain(chainDetails) {\n        var _a;\n        if (await this.networkStore.get(chainDetails.chainId)) {\n            throw new Error('Chain already exists');\n        }\n        if (!(((_a = chainDetails.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) > 0)) {\n            throw new Error('RPC url is required when adding a chain');\n        }\n        await this.networkStore.add(chainDetails);\n        return null;\n    }\n    async switchChain(chainDetails) {\n        const network = await this.networkStore.get(chainDetails.chainId);\n        if (!network) {\n            throw new ProviderError('Chain does not exist', 4902);\n        }\n        this.currentProviderPromise = this.setupChain(network);\n        this.emit('chainChanged');\n        return null;\n    }\n    async setupChain(network) {\n        let provider = this.networkProviderStore.get(network);\n        if (!provider) {\n            const sdk = await this.sdkPromise;\n            if (!sdk) {\n                throw new Error('Bitski SDK not available');\n            }\n            provider = sdk.createProvider(network, this.providerOptions);\n            // Add all previously added providers to the new chain\n            for (const [subprovider, index] of this.subproviders) {\n                provider.addProvider(subprovider, index);\n            }\n            // Override provider emit so it emits directly to the wrapper/loader\n            provider.emit = this.emit.bind(this);\n            this.networkProviderStore.set(network, provider);\n            provider.start();\n        }\n        // Set current provider so we can access it for non-async values\n        this.currentProvider = provider;\n        this.currentChainId = toHex(network.chainId);\n        return provider;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}