{"ast":null,"code":"import PollingBlockTracker from 'eth-block-tracker';\nimport { EventEmitter } from 'events';\nimport { BlockTrackerError } from '../errors/block-tracker-error';\nimport { createPayload } from './create-payload';\nimport { toBuffer } from './eth-util';\n// Class responsible for tracking new blocks as they are mined,\n// loading them, parsing them, and alerting subscribers via events.\nexport default class BlockTracker extends EventEmitter {\n  constructor(opts) {\n    super();\n    // Number of milliseconds to wait before retrying\n    this.blockTimeout = 300;\n    // Maximum attempts to load a block\n    this.maxBlockRetries = 3;\n    this.provider = opts.provider;\n    this._blockTracker = opts.blockTracker || new PollingBlockTracker(Object.assign({}, opts, {\n      setSkipCacheFlag: true\n    }));\n  }\n  start() {\n    this.createSubscriptions();\n  }\n  stop() {\n    this.destroySubscriptions();\n  }\n  getLatestBlock() {\n    return this._blockTracker.checkForLatestBlock().catch(error => {\n      this.emit('error', error);\n    });\n  }\n  createSubscriptions() {\n    // on new block, request block body and emit as events\n    this._blockTracker.on('latest', this.onLatest.bind(this));\n    // forward other events\n    this._blockTracker.on('sync', this.emit.bind(this, 'sync'));\n    this._blockTracker.on('error', this.emit.bind(this, 'error'));\n  }\n  destroySubscriptions() {\n    // stop block polling by removing event listeners\n    this._blockTracker.removeAllListeners();\n  }\n  onLatest(blockNumber) {\n    this.currentBlockNumber = blockNumber;\n    this.loadBlock(blockNumber);\n  }\n  // Tries to get the block payload recursively\n  loadBlock(blockNumber) {\n    let callCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._getBlockByNumber(blockNumber).then(blockResponse => {\n      // Result can be null if the block hasn't fully propagated to the nodes\n      if (blockResponse.result) {\n        this.updateBlock(blockResponse.result);\n      } else if (callCount < this.maxBlockRetries && blockNumber === this.currentBlockNumber) {\n        // Only call recursively if the current block number is still the same\n        // and if we are under the retry limit.\n        setTimeout(() => {\n          this.loadBlock(blockNumber, callCount + 1);\n        }, this.blockTimeout);\n      } else {\n        throw BlockTrackerError.BlockNotFound(blockNumber);\n      }\n    }).catch(err => {\n      // Don't retry for errors (provider should have already retried)\n      this.emit('error', err);\n    });\n  }\n  _getBlockByNumber(blockNumber) {\n    const req = createPayload({\n      method: 'eth_getBlockByNumber',\n      params: [blockNumber, false],\n      skipCache: true\n    });\n    return new Promise((fulfill, reject) => {\n      this.provider.sendAsync(req, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        fulfill(result);\n      });\n    });\n  }\n  // Parse the block into a buffer representation and update subscribers.\n  updateBlock(block) {\n    const bufferBlock = toBufferBlock(block);\n    // set current + emit \"block\" event\n    this._setCurrentBlock(bufferBlock);\n    // emit other events\n    this.emit('rawBlock', block);\n    this.emit('latest', block);\n  }\n  _setCurrentBlock(bufferBlock) {\n    this.currentBlock = bufferBlock;\n    this.emit('block', bufferBlock);\n  }\n}\n// util\nfunction toBufferBlock(jsonBlock) {\n  return {\n    number: toBuffer(jsonBlock.number),\n    hash: toBuffer(jsonBlock.hash),\n    parentHash: toBuffer(jsonBlock.parentHash),\n    nonce: toBuffer(jsonBlock.nonce),\n    mixHash: toBuffer(jsonBlock.mixHash),\n    sha3Uncles: toBuffer(jsonBlock.sha3Uncles),\n    logsBloom: toBuffer(jsonBlock.logsBloom),\n    transactionsRoot: toBuffer(jsonBlock.transactionsRoot),\n    stateRoot: toBuffer(jsonBlock.stateRoot),\n    receiptsRoot: toBuffer(jsonBlock.receiptsRoot),\n    miner: toBuffer(jsonBlock.miner),\n    difficulty: toBuffer(jsonBlock.difficulty),\n    totalDifficulty: toBuffer(jsonBlock.totalDifficulty),\n    size: toBuffer(jsonBlock.size),\n    extraData: toBuffer(jsonBlock.extraData),\n    gasLimit: toBuffer(jsonBlock.gasLimit),\n    gasUsed: toBuffer(jsonBlock.gasUsed),\n    timestamp: toBuffer(jsonBlock.timestamp),\n    transactions: jsonBlock.transactions\n  };\n}","map":{"version":3,"names":["PollingBlockTracker","EventEmitter","BlockTrackerError","createPayload","toBuffer","BlockTracker","constructor","opts","blockTimeout","maxBlockRetries","provider","_blockTracker","blockTracker","Object","assign","setSkipCacheFlag","start","createSubscriptions","stop","destroySubscriptions","getLatestBlock","checkForLatestBlock","catch","error","emit","on","onLatest","bind","removeAllListeners","blockNumber","currentBlockNumber","loadBlock","callCount","_getBlockByNumber","then","blockResponse","result","updateBlock","setTimeout","BlockNotFound","err","req","method","params","skipCache","Promise","fulfill","reject","sendAsync","block","bufferBlock","toBufferBlock","_setCurrentBlock","currentBlock","jsonBlock","number","hash","parentHash","nonce","mixHash","sha3Uncles","logsBloom","transactionsRoot","stateRoot","receiptsRoot","miner","difficulty","totalDifficulty","size","extraData","gasLimit","gasUsed","timestamp","transactions"],"sources":["/Users/charvai/Desktop/template/node_modules/@bitski/provider-engine/dist/modules/util/block-tracker.js"],"sourcesContent":["import PollingBlockTracker from 'eth-block-tracker';\nimport { EventEmitter } from 'events';\nimport { BlockTrackerError } from '../errors/block-tracker-error';\nimport { createPayload } from './create-payload';\nimport { toBuffer } from './eth-util';\n// Class responsible for tracking new blocks as they are mined,\n// loading them, parsing them, and alerting subscribers via events.\nexport default class BlockTracker extends EventEmitter {\n    constructor(opts) {\n        super();\n        // Number of milliseconds to wait before retrying\n        this.blockTimeout = 300;\n        // Maximum attempts to load a block\n        this.maxBlockRetries = 3;\n        this.provider = opts.provider;\n        this._blockTracker = opts.blockTracker || new PollingBlockTracker(Object.assign({}, opts, { setSkipCacheFlag: true }));\n    }\n    start() {\n        this.createSubscriptions();\n    }\n    stop() {\n        this.destroySubscriptions();\n    }\n    getLatestBlock() {\n        return this._blockTracker.checkForLatestBlock().catch((error) => {\n            this.emit('error', error);\n        });\n    }\n    createSubscriptions() {\n        // on new block, request block body and emit as events\n        this._blockTracker.on('latest', this.onLatest.bind(this));\n        // forward other events\n        this._blockTracker.on('sync', this.emit.bind(this, 'sync'));\n        this._blockTracker.on('error', this.emit.bind(this, 'error'));\n    }\n    destroySubscriptions() {\n        // stop block polling by removing event listeners\n        this._blockTracker.removeAllListeners();\n    }\n    onLatest(blockNumber) {\n        this.currentBlockNumber = blockNumber;\n        this.loadBlock(blockNumber);\n    }\n    // Tries to get the block payload recursively\n    loadBlock(blockNumber, callCount = 0) {\n        this._getBlockByNumber(blockNumber).then((blockResponse) => {\n            // Result can be null if the block hasn't fully propagated to the nodes\n            if (blockResponse.result) {\n                this.updateBlock(blockResponse.result);\n            }\n            else if (callCount < this.maxBlockRetries && blockNumber === this.currentBlockNumber) {\n                // Only call recursively if the current block number is still the same\n                // and if we are under the retry limit.\n                setTimeout(() => {\n                    this.loadBlock(blockNumber, callCount + 1);\n                }, this.blockTimeout);\n            }\n            else {\n                throw BlockTrackerError.BlockNotFound(blockNumber);\n            }\n        }).catch((err) => {\n            // Don't retry for errors (provider should have already retried)\n            this.emit('error', err);\n        });\n    }\n    _getBlockByNumber(blockNumber) {\n        const req = createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true });\n        return new Promise((fulfill, reject) => {\n            this.provider.sendAsync(req, (err, result) => {\n                if (err) {\n                    return reject(err);\n                }\n                fulfill(result);\n            });\n        });\n    }\n    // Parse the block into a buffer representation and update subscribers.\n    updateBlock(block) {\n        const bufferBlock = toBufferBlock(block);\n        // set current + emit \"block\" event\n        this._setCurrentBlock(bufferBlock);\n        // emit other events\n        this.emit('rawBlock', block);\n        this.emit('latest', block);\n    }\n    _setCurrentBlock(bufferBlock) {\n        this.currentBlock = bufferBlock;\n        this.emit('block', bufferBlock);\n    }\n}\n// util\nfunction toBufferBlock(jsonBlock) {\n    return {\n        number: toBuffer(jsonBlock.number),\n        hash: toBuffer(jsonBlock.hash),\n        parentHash: toBuffer(jsonBlock.parentHash),\n        nonce: toBuffer(jsonBlock.nonce),\n        mixHash: toBuffer(jsonBlock.mixHash),\n        sha3Uncles: toBuffer(jsonBlock.sha3Uncles),\n        logsBloom: toBuffer(jsonBlock.logsBloom),\n        transactionsRoot: toBuffer(jsonBlock.transactionsRoot),\n        stateRoot: toBuffer(jsonBlock.stateRoot),\n        receiptsRoot: toBuffer(jsonBlock.receiptsRoot),\n        miner: toBuffer(jsonBlock.miner),\n        difficulty: toBuffer(jsonBlock.difficulty),\n        totalDifficulty: toBuffer(jsonBlock.totalDifficulty),\n        size: toBuffer(jsonBlock.size),\n        extraData: toBuffer(jsonBlock.extraData),\n        gasLimit: toBuffer(jsonBlock.gasLimit),\n        gasUsed: toBuffer(jsonBlock.gasUsed),\n        timestamp: toBuffer(jsonBlock.timestamp),\n        transactions: jsonBlock.transactions,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}