{"ast":null,"code":"import { Subprovider } from '@bitski/provider-engine';\nimport { ProviderError } from '../errors/provider-error';\nimport { encodeNumber } from '../utils/parse-utils';\nexport class TypedDataSanitizerSubprovider extends Subprovider {\n  handleRequest(payload, next, end) {\n    if (payload.method === 'eth_signTypedData' || payload.method === 'eth_signTypedData_v3' || payload.method === 'eth_signTypedData_v4') {\n      try {\n        this.sanitizePayload(payload);\n      } catch (err) {\n        return end(err, undefined);\n      }\n    }\n    next();\n  }\n  sanitizePayload(payload) {\n    const typedData = this.extractTypedData(payload);\n    // create map of types\n    const typeMapping = createTypeMapping(typedData);\n    // sanitize domain if available\n    if (typedData.domain || typedData.types.EIP712Domain) {\n      sanitizeDomain(typedData, typeMapping);\n    }\n    // sanitize message\n    sanitizeMessage(typedData, typeMapping);\n    // Re-assign typed data to params in case it has been parsed\n    // from a string.\n    payload.params[1] = typedData;\n  }\n  // Given a JSON-RPC request, extract the typed data from the params\n  extractTypedData(payload) {\n    if (!payload.params || payload.params.length < 2) {\n      throw ProviderError.InvalidRequest('Missing params for typed data');\n    }\n    // Some implementations pass typed data as a string\n    if (typeof payload.params[1] === 'string') {\n      return JSON.parse(payload.params[1]);\n    }\n    return payload.params[1];\n  }\n}\n/**\n * Sanitizes the `domain` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeDomain(typedData, typeMapping) {\n  if (typeof typedData.domain === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing domain for typed data');\n  }\n  sanitizeType('EIP712Domain', typedData.domain, typeMapping);\n}\n/**\n * Sanitizes the `message` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeMessage(typedData, typeMapping) {\n  if (typeof typedData.message === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing message in typed data');\n  }\n  if (typeof typedData.primaryType !== 'string') {\n    throw ProviderError.InvalidRequest('Missing primary type in typed data');\n  }\n  sanitizeType(typedData.primaryType, typedData.message, typeMapping);\n}\n/**\n * Recursively examines each value and determines type from the type mapping to\n * format and sanitize the value if needed.\n *\n * Currently this will only convert number values into a consistent hex format,\n * but in the future additional transformations may be necessary.\n *\n * @param typeName Name of the type we are starting from\n * @param values The root object containing the keys and values\n * @param typeMapping The type mapping that represents this data\n */\nexport function sanitizeType(typeName, values, typeMapping) {\n  // For each key in the 'values' object...\n  Object.keys(values).forEach(key => {\n    // Find the type name associated from the mapping\n    const type = typeMapping[typeName][key];\n    if (type === undefined) {\n      // Do nothing if we don't have a type for this key\n    } else if (isArray(type)) {\n      // find the base type (left side of the brackets)\n      const baseType = type.split('[')[0];\n      if (typeof values[key].length === 'undefined') {\n        throw new TypeError(`Could not parse ${values[key]} for type ${type}. Expected array.`);\n      }\n      // If base type is a struct, iterate through each instance of struct\n      if (typeMapping[baseType]) {\n        // values[key] is expected to be an array, where each element\n        // is an object that represents the struct named baseType.\n        values[key].forEach(itemValues => {\n          sanitizeType(baseType, itemValues, typeMapping);\n        });\n      } else if (baseType.startsWith('uint') || baseType.startsWith('int')) {\n        // If we have an array of primitive types that are numbers, we need to encode the numbers as hex\n        const numberValues = values[key].map(numberValue => {\n          return encodeNumber(numberValue, baseType, true);\n        });\n        values[key] = numberValues;\n      } else {\n        // Do nothing with regular array values\n        // int8[], etc should already be strings\n      }\n    } else if (typeMapping[type]) {\n      // If type name is a custom struct, it should live in the type mapping\n      // We need to recursively check the custom types until we get to primitive values\n      sanitizeType(type, values[key], typeMapping);\n    } else if (type.startsWith('uint') || type.startsWith('int')) {\n      // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex\n      values[key] = encodeNumber(values[key], type, true);\n    }\n  });\n}\n/**\n * Returns true if type name indicates that an array\n * @param typeName solidity type name\n */\nfunction isArray(typeName) {\n  if (typeName.includes('[') && typeName.includes(']')) {\n    return true;\n  }\n  return false;\n}\n/**\n * Maps the type definitions from the typed data for easy look-up.\n * Top level keys represent the structs defined, while top-level values\n * are an object keyed by property with string values of the type name.\n *\n * For example:\n * {\n *    EIP712Domain: {\n *      name: 'string',\n *      version: 'string',\n *      chainId: 'uint256'\n *    }\n * }\n * @param typedData The TypedData to map\n * @returns {TypeMapping} the mapped data schema\n */\nexport function createTypeMapping(typedData) {\n  if (typeof typedData.types === 'undefined') {\n    throw ProviderError.InvalidRequest('Missing type definitions for typed data');\n  }\n  // Go through each of the top level keys. These represent the custom types.\n  return Object.keys(typedData.types).reduce((acc, current) => {\n    // Reduce into a new single object\n    // Set a key for each type, reduce array of property names and types to an object\n    acc[current] = typedData.types[current].reduce((acc2, typeDef) => {\n      // For each type, set the key as the property name, and the value as the type name\n      acc2[typeDef.name] = typeDef.type;\n      return acc2;\n    }, {});\n    return acc;\n  }, {});\n}","map":{"version":3,"names":["Subprovider","ProviderError","encodeNumber","TypedDataSanitizerSubprovider","handleRequest","payload","next","end","method","sanitizePayload","err","undefined","typedData","extractTypedData","typeMapping","createTypeMapping","domain","types","EIP712Domain","sanitizeDomain","sanitizeMessage","params","length","InvalidRequest","JSON","parse","sanitizeType","message","primaryType","typeName","values","Object","keys","forEach","key","type","isArray","baseType","split","TypeError","itemValues","startsWith","numberValues","map","numberValue","includes","reduce","acc","current","acc2","typeDef","name"],"sources":["/Users/charvai/Desktop/template/node_modules/bitski-provider/dist/subproviders/typed-data.js"],"sourcesContent":["import { Subprovider } from '@bitski/provider-engine';\nimport { ProviderError } from '../errors/provider-error';\nimport { encodeNumber } from '../utils/parse-utils';\nexport class TypedDataSanitizerSubprovider extends Subprovider {\n    handleRequest(payload, next, end) {\n        if (payload.method === 'eth_signTypedData' ||\n            payload.method === 'eth_signTypedData_v3' ||\n            payload.method === 'eth_signTypedData_v4') {\n            try {\n                this.sanitizePayload(payload);\n            }\n            catch (err) {\n                return end(err, undefined);\n            }\n        }\n        next();\n    }\n    sanitizePayload(payload) {\n        const typedData = this.extractTypedData(payload);\n        // create map of types\n        const typeMapping = createTypeMapping(typedData);\n        // sanitize domain if available\n        if (typedData.domain || typedData.types.EIP712Domain) {\n            sanitizeDomain(typedData, typeMapping);\n        }\n        // sanitize message\n        sanitizeMessage(typedData, typeMapping);\n        // Re-assign typed data to params in case it has been parsed\n        // from a string.\n        payload.params[1] = typedData;\n    }\n    // Given a JSON-RPC request, extract the typed data from the params\n    extractTypedData(payload) {\n        if (!payload.params || payload.params.length < 2) {\n            throw ProviderError.InvalidRequest('Missing params for typed data');\n        }\n        // Some implementations pass typed data as a string\n        if (typeof payload.params[1] === 'string') {\n            return JSON.parse(payload.params[1]);\n        }\n        return payload.params[1];\n    }\n}\n/**\n * Sanitizes the `domain` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeDomain(typedData, typeMapping) {\n    if (typeof typedData.domain === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing domain for typed data');\n    }\n    sanitizeType('EIP712Domain', typedData.domain, typeMapping);\n}\n/**\n * Sanitizes the `message` values from the TypedData\n *\n * @param typedData TypedData payload\n * @param typeMapping a TypeMapping pre-generated from the TypedData\n */\nexport function sanitizeMessage(typedData, typeMapping) {\n    if (typeof typedData.message === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing message in typed data');\n    }\n    if (typeof typedData.primaryType !== 'string') {\n        throw ProviderError.InvalidRequest('Missing primary type in typed data');\n    }\n    sanitizeType(typedData.primaryType, typedData.message, typeMapping);\n}\n/**\n * Recursively examines each value and determines type from the type mapping to\n * format and sanitize the value if needed.\n *\n * Currently this will only convert number values into a consistent hex format,\n * but in the future additional transformations may be necessary.\n *\n * @param typeName Name of the type we are starting from\n * @param values The root object containing the keys and values\n * @param typeMapping The type mapping that represents this data\n */\nexport function sanitizeType(typeName, values, typeMapping) {\n    // For each key in the 'values' object...\n    Object.keys(values).forEach((key) => {\n        // Find the type name associated from the mapping\n        const type = typeMapping[typeName][key];\n        if (type === undefined) {\n            // Do nothing if we don't have a type for this key\n        }\n        else if (isArray(type)) {\n            // find the base type (left side of the brackets)\n            const baseType = type.split('[')[0];\n            if (typeof values[key].length === 'undefined') {\n                throw new TypeError(`Could not parse ${values[key]} for type ${type}. Expected array.`);\n            }\n            // If base type is a struct, iterate through each instance of struct\n            if (typeMapping[baseType]) {\n                // values[key] is expected to be an array, where each element\n                // is an object that represents the struct named baseType.\n                values[key].forEach((itemValues) => {\n                    sanitizeType(baseType, itemValues, typeMapping);\n                });\n            }\n            else if (baseType.startsWith('uint') || baseType.startsWith('int')) {\n                // If we have an array of primitive types that are numbers, we need to encode the numbers as hex\n                const numberValues = values[key].map((numberValue) => {\n                    return encodeNumber(numberValue, baseType, true);\n                });\n                values[key] = numberValues;\n            }\n            else {\n                // Do nothing with regular array values\n                // int8[], etc should already be strings\n            }\n        }\n        else if (typeMapping[type]) {\n            // If type name is a custom struct, it should live in the type mapping\n            // We need to recursively check the custom types until we get to primitive values\n            sanitizeType(type, values[key], typeMapping);\n        }\n        else if (type.startsWith('uint') || type.startsWith('int')) {\n            // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex\n            values[key] = encodeNumber(values[key], type, true);\n        }\n    });\n}\n/**\n * Returns true if type name indicates that an array\n * @param typeName solidity type name\n */\nfunction isArray(typeName) {\n    if (typeName.includes('[') && typeName.includes(']')) {\n        return true;\n    }\n    return false;\n}\n/**\n * Maps the type definitions from the typed data for easy look-up.\n * Top level keys represent the structs defined, while top-level values\n * are an object keyed by property with string values of the type name.\n *\n * For example:\n * {\n *    EIP712Domain: {\n *      name: 'string',\n *      version: 'string',\n *      chainId: 'uint256'\n *    }\n * }\n * @param typedData The TypedData to map\n * @returns {TypeMapping} the mapped data schema\n */\nexport function createTypeMapping(typedData) {\n    if (typeof typedData.types === 'undefined') {\n        throw ProviderError.InvalidRequest('Missing type definitions for typed data');\n    }\n    // Go through each of the top level keys. These represent the custom types.\n    return Object.keys(typedData.types).reduce((acc, current) => {\n        // Reduce into a new single object\n        // Set a key for each type, reduce array of property names and types to an object\n        acc[current] = typedData.types[current].reduce((acc2, typeDef) => {\n            // For each type, set the key as the property name, and the value as the type name\n            acc2[typeDef.name] = typeDef.type;\n            return acc2;\n        }, {});\n        return acc;\n    }, {});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}