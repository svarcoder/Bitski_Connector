{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nexport class HttpConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    this.url = url;\n  }\n  get connected() {\n    return this.isAvailable;\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n  async close() {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n    this.onClose();\n  }\n  async send(payload, context) {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      const data = await res.json();\n      this.onPayload({\n        data\n      });\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n  async register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (this.events.listenerCount(\"register_error\") >= currentMaxListeners || this.events.listenerCount(\"open\") >= currentMaxListeners) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n          resolve();\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    try {\n      const body = safeJsonStringify({\n        id: 1,\n        jsonrpc: \"2.0\",\n        method: \"test\",\n        params: []\n      });\n      await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n  onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n  onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n  resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n}\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nexport class HttpConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            const currentMaxListeners = this.events.getMaxListeners();\n            if (this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n                this.events.listenerCount(\"open\") >= currentMaxListeners) {\n                this.events.setMaxListeners(currentMaxListeners + 1);\n            }\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    this.resetMaxListeners();\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    this.resetMaxListeners();\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n            await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n    resetMaxListeners() {\n        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n        }\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}