{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from \"events\";\nimport { ethers } from \"ethers\";\nimport { version } from \"./_version\";\nconst logger = new ethers.utils.Logger(version);\n/*\nfunction getBlockTag(tag) {\n    if (tag == null) { return \"latest\"; }\n    if (tag === \"earliest\" || tag === \"latest\" || tag === \"pending\") {\n        return tag;\n    }\n    return ethers.utils.hexValue(tag)\n}\n*/\nexport class Eip1193Bridge extends EventEmitter {\n  constructor(signer, provider) {\n    super();\n    ethers.utils.defineReadOnly(this, \"signer\", signer);\n    ethers.utils.defineReadOnly(this, \"provider\", provider || null);\n  }\n  request(request) {\n    return this.send(request.method, request.params || []);\n  }\n  send(method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      function throwUnsupported(message) {\n        return logger.throwError(message, ethers.utils.Logger.errors.UNSUPPORTED_OPERATION, {\n          method: method,\n          params: params\n        });\n      }\n      let coerce = value => value;\n      switch (method) {\n        case \"eth_gasPrice\":\n          {\n            const result = yield this.provider.getGasPrice();\n            return result.toHexString();\n          }\n        case \"eth_accounts\":\n          {\n            const result = [];\n            if (this.signer) {\n              const address = yield this.signer.getAddress();\n              result.push(address);\n            }\n            return result;\n          }\n        case \"eth_blockNumber\":\n          {\n            return yield this.provider.getBlockNumber();\n          }\n        case \"eth_chainId\":\n          {\n            const result = yield this.provider.getNetwork();\n            return ethers.utils.hexValue(result.chainId);\n          }\n        case \"eth_getBalance\":\n          {\n            const result = yield this.provider.getBalance(params[0], params[1]);\n            return result.toHexString();\n          }\n        case \"eth_getStorageAt\":\n          {\n            return this.provider.getStorageAt(params[0], params[1], params[2]);\n          }\n        case \"eth_getTransactionCount\":\n          {\n            const result = yield this.provider.getTransactionCount(params[0], params[1]);\n            return ethers.utils.hexValue(result);\n          }\n        case \"eth_getBlockTransactionCountByHash\":\n        case \"eth_getBlockTransactionCountByNumber\":\n          {\n            const result = yield this.provider.getBlock(params[0]);\n            return ethers.utils.hexValue(result.transactions.length);\n          }\n        case \"eth_getCode\":\n          {\n            const result = yield this.provider.getCode(params[0], params[1]);\n            return result;\n          }\n        case \"eth_sendRawTransaction\":\n          {\n            return yield this.provider.sendTransaction(params[0]);\n          }\n        case \"eth_call\":\n          {\n            const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n            return yield this.provider.call(req, params[1]);\n          }\n        case \"estimateGas\":\n          {\n            if (params[1] && params[1] !== \"latest\") {\n              throwUnsupported(\"estimateGas does not support blockTag\");\n            }\n            const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n            const result = yield this.provider.estimateGas(req);\n            return result.toHexString();\n          }\n        // @TODO: Transform? No uncles?\n        case \"eth_getBlockByHash\":\n        case \"eth_getBlockByNumber\":\n          {\n            if (params[1]) {\n              return yield this.provider.getBlockWithTransactions(params[0]);\n            } else {\n              return yield this.provider.getBlock(params[0]);\n            }\n          }\n        case \"eth_getTransactionByHash\":\n          {\n            return yield this.provider.getTransaction(params[0]);\n          }\n        case \"eth_getTransactionReceipt\":\n          {\n            return yield this.provider.getTransactionReceipt(params[0]);\n          }\n        case \"eth_sign\":\n          {\n            if (!this.signer) {\n              return throwUnsupported(\"eth_sign requires an account\");\n            }\n            const address = yield this.signer.getAddress();\n            if (address !== ethers.utils.getAddress(params[0])) {\n              logger.throwArgumentError(\"account mismatch or account not found\", \"params[0]\", params[0]);\n            }\n            return this.signer.signMessage(ethers.utils.arrayify(params[1]));\n          }\n        case \"eth_sendTransaction\":\n          {\n            if (!this.signer) {\n              return throwUnsupported(\"eth_sendTransaction requires an account\");\n            }\n            const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n            const tx = yield this.signer.sendTransaction(req);\n            return tx.hash;\n          }\n        case \"eth_getUncleCountByBlockHash\":\n        case \"eth_getUncleCountByBlockNumber\":\n          {\n            coerce = ethers.utils.hexValue;\n            break;\n          }\n        case \"eth_getTransactionByBlockHashAndIndex\":\n        case \"eth_getTransactionByBlockNumberAndIndex\":\n        case \"eth_getUncleByBlockHashAndIndex\":\n        case \"eth_getUncleByBlockNumberAndIndex\":\n        case \"eth_newFilter\":\n        case \"eth_newBlockFilter\":\n        case \"eth_newPendingTransactionFilter\":\n        case \"eth_uninstallFilter\":\n        case \"eth_getFilterChanges\":\n        case \"eth_getFilterLogs\":\n        case \"eth_getLogs\":\n          break;\n      }\n      // If our provider supports send, maybe it can do a better job?\n      if (this.provider.send) {\n        const result = yield this.provider.send(method, params);\n        return coerce(result);\n      }\n      return throwUnsupported(`unsupported method: ${method}`);\n    });\n  }\n}","map":{"version":3,"sources":["../src.ts/eip1193-bridge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from \"events\";\nimport { ethers } from \"ethers\";\nimport { version } from \"./_version\";\nconst logger = new ethers.utils.Logger(version);\n/*\nfunction getBlockTag(tag) {\n    if (tag == null) { return \"latest\"; }\n    if (tag === \"earliest\" || tag === \"latest\" || tag === \"pending\") {\n        return tag;\n    }\n    return ethers.utils.hexValue(tag)\n}\n*/\nexport class Eip1193Bridge extends EventEmitter {\n    constructor(signer, provider) {\n        super();\n        ethers.utils.defineReadOnly(this, \"signer\", signer);\n        ethers.utils.defineReadOnly(this, \"provider\", provider || null);\n    }\n    request(request) {\n        return this.send(request.method, request.params || []);\n    }\n    send(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            function throwUnsupported(message) {\n                return logger.throwError(message, ethers.utils.Logger.errors.UNSUPPORTED_OPERATION, {\n                    method: method,\n                    params: params\n                });\n            }\n            let coerce = (value) => value;\n            switch (method) {\n                case \"eth_gasPrice\": {\n                    const result = yield this.provider.getGasPrice();\n                    return result.toHexString();\n                }\n                case \"eth_accounts\": {\n                    const result = [];\n                    if (this.signer) {\n                        const address = yield this.signer.getAddress();\n                        result.push(address);\n                    }\n                    return result;\n                }\n                case \"eth_blockNumber\": {\n                    return yield this.provider.getBlockNumber();\n                }\n                case \"eth_chainId\": {\n                    const result = yield this.provider.getNetwork();\n                    return ethers.utils.hexValue(result.chainId);\n                }\n                case \"eth_getBalance\": {\n                    const result = yield this.provider.getBalance(params[0], params[1]);\n                    return result.toHexString();\n                }\n                case \"eth_getStorageAt\": {\n                    return this.provider.getStorageAt(params[0], params[1], params[2]);\n                }\n                case \"eth_getTransactionCount\": {\n                    const result = yield this.provider.getTransactionCount(params[0], params[1]);\n                    return ethers.utils.hexValue(result);\n                }\n                case \"eth_getBlockTransactionCountByHash\":\n                case \"eth_getBlockTransactionCountByNumber\": {\n                    const result = yield this.provider.getBlock(params[0]);\n                    return ethers.utils.hexValue(result.transactions.length);\n                }\n                case \"eth_getCode\": {\n                    const result = yield this.provider.getCode(params[0], params[1]);\n                    return result;\n                }\n                case \"eth_sendRawTransaction\": {\n                    return yield this.provider.sendTransaction(params[0]);\n                }\n                case \"eth_call\": {\n                    const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n                    return yield this.provider.call(req, params[1]);\n                }\n                case \"estimateGas\": {\n                    if (params[1] && params[1] !== \"latest\") {\n                        throwUnsupported(\"estimateGas does not support blockTag\");\n                    }\n                    const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n                    const result = yield this.provider.estimateGas(req);\n                    return result.toHexString();\n                }\n                // @TODO: Transform? No uncles?\n                case \"eth_getBlockByHash\":\n                case \"eth_getBlockByNumber\": {\n                    if (params[1]) {\n                        return yield this.provider.getBlockWithTransactions(params[0]);\n                    }\n                    else {\n                        return yield this.provider.getBlock(params[0]);\n                    }\n                }\n                case \"eth_getTransactionByHash\": {\n                    return yield this.provider.getTransaction(params[0]);\n                }\n                case \"eth_getTransactionReceipt\": {\n                    return yield this.provider.getTransactionReceipt(params[0]);\n                }\n                case \"eth_sign\": {\n                    if (!this.signer) {\n                        return throwUnsupported(\"eth_sign requires an account\");\n                    }\n                    const address = yield this.signer.getAddress();\n                    if (address !== ethers.utils.getAddress(params[0])) {\n                        logger.throwArgumentError(\"account mismatch or account not found\", \"params[0]\", params[0]);\n                    }\n                    return this.signer.signMessage(ethers.utils.arrayify(params[1]));\n                }\n                case \"eth_sendTransaction\": {\n                    if (!this.signer) {\n                        return throwUnsupported(\"eth_sendTransaction requires an account\");\n                    }\n                    const req = ethers.providers.JsonRpcProvider.hexlifyTransaction(params[0]);\n                    const tx = yield this.signer.sendTransaction(req);\n                    return tx.hash;\n                }\n                case \"eth_getUncleCountByBlockHash\":\n                case \"eth_getUncleCountByBlockNumber\":\n                    {\n                        coerce = ethers.utils.hexValue;\n                        break;\n                    }\n                case \"eth_getTransactionByBlockHashAndIndex\":\n                case \"eth_getTransactionByBlockNumberAndIndex\":\n                case \"eth_getUncleByBlockHashAndIndex\":\n                case \"eth_getUncleByBlockNumberAndIndex\":\n                case \"eth_newFilter\":\n                case \"eth_newBlockFilter\":\n                case \"eth_newPendingTransactionFilter\":\n                case \"eth_uninstallFilter\":\n                case \"eth_getFilterChanges\":\n                case \"eth_getFilterLogs\":\n                case \"eth_getLogs\":\n                    break;\n            }\n            // If our provider supports send, maybe it can do a better job?\n            if ((this.provider).send) {\n                const result = yield (this.provider).send(method, params);\n                return coerce(result);\n            }\n            return throwUnsupported(`unsupported method: ${method}`);\n        });\n    }\n}\n//# sourceMappingURL=eip1193-bridge.js.map"]},"metadata":{},"sourceType":"module"}