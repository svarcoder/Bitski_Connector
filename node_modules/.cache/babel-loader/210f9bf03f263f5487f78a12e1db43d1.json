{"ast":null,"code":"import asyncify from 'async/asyncify';\nimport retry from 'async/retry';\nimport waterfall from 'async/waterfall';\nimport JsonRpcError from 'json-rpc-error';\nimport promiseToCallback from 'promise-to-callback';\nimport Subprovider from '../subprovider';\nimport { createPayload } from '../util/create-payload';\nconst RETRIABLE_ERRORS = [\n// ignore server overload errors\n'Gateway timeout', 'ETIMEDOUT',\n// ignore server sent html error pages\n// or truncated json responses\n'SyntaxError', 'failed to parse response body',\n// ignore errors where http req failed to establish\n'Failed to fetch'];\nexport default class FetchSubprovider extends Subprovider {\n  constructor(opts) {\n    super();\n    this.rpcUrl = opts.rpcUrl;\n    this.originHttpHeaderKey = opts.originHttpHeaderKey;\n  }\n  handleRequest(payload, next, end) {\n    const originDomain = payload.origin;\n    // overwrite id to not conflict with other concurrent users\n    const newPayload = this.createPayload(payload);\n    // remove extra parameter from request\n    delete newPayload.origin;\n    const reqParams = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(newPayload)\n    };\n    if (this.originHttpHeaderKey && originDomain) {\n      reqParams.headers[this.originHttpHeaderKey] = originDomain;\n    }\n    retry({\n      times: 5,\n      interval: 1000,\n      errorFilter: isErrorRetriable\n    }, cb => this._submitRequest(reqParams, cb), (err, result) => {\n      // ends on retriable error\n      if (err && isErrorRetriable(err)) {\n        const errMsg = `FetchSubprovider - cannot complete request. All retries exhausted.\\nOriginal Error:\\n${err.toString()}\\n\\n`;\n        const retriesExhaustedErr = new Error(errMsg);\n        return end(retriesExhaustedErr);\n      }\n      // otherwise continue normally\n      return end(err, result);\n    });\n  }\n  createPayload(payload) {\n    return createPayload(payload);\n  }\n  _submitRequest(reqParams, done) {\n    const targetUrl = this.rpcUrl;\n    promiseToCallback(fetch(targetUrl, reqParams))((err, res) => {\n      if (err) {\n        return done(err);\n      }\n      // continue parsing result\n      waterfall([checkForHttpErrors,\n      // buffer body\n      cb => promiseToCallback(res.text())(cb),\n      // parse body\n      asyncify(rawBody => JSON.parse(rawBody)), parseResponse], done);\n      function checkForHttpErrors(cb) {\n        // check for errors\n        switch (res.status) {\n          case 405:\n            return cb(new JsonRpcError.MethodNotFound());\n          case 418:\n            return cb(createRatelimitError());\n          case 503:\n          case 504:\n            return cb(createTimeoutError());\n          default:\n            return cb();\n        }\n      }\n      function parseResponse(body, cb) {\n        // check for error code\n        if (res.status !== 200) {\n          return cb(new JsonRpcError.InternalError(body));\n        }\n        // check for rpc error\n        if (body.error) {\n          return cb(new JsonRpcError.InternalError(body.error));\n        }\n        // return successful result\n        cb(null, body.result);\n      }\n    });\n  }\n}\nfunction isErrorRetriable(err) {\n  const errMsg = err.toString();\n  return RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));\n}\nfunction createRatelimitError() {\n  const msg = 'Request is being rate limited.';\n  const err = new Error(msg);\n  return new JsonRpcError.InternalError(err);\n}\nfunction createTimeoutError() {\n  let msg = 'Gateway timeout. The request took too long to process. ';\n  msg += 'This can happen when querying logs over too wide a block range.';\n  const err = new Error(msg);\n  return new JsonRpcError.InternalError(err);\n}","map":{"version":3,"names":["asyncify","retry","waterfall","JsonRpcError","promiseToCallback","Subprovider","createPayload","RETRIABLE_ERRORS","FetchSubprovider","constructor","opts","rpcUrl","originHttpHeaderKey","handleRequest","payload","next","end","originDomain","origin","newPayload","reqParams","method","headers","body","JSON","stringify","times","interval","errorFilter","isErrorRetriable","cb","_submitRequest","err","result","errMsg","toString","retriesExhaustedErr","Error","done","targetUrl","fetch","res","checkForHttpErrors","text","rawBody","parse","parseResponse","status","MethodNotFound","createRatelimitError","createTimeoutError","InternalError","error","some","phrase","includes","msg"],"sources":["/Users/charvai/Desktop/template/node_modules/@bitski/provider-engine/dist/modules/subproviders/fetch.js"],"sourcesContent":["import asyncify from 'async/asyncify';\nimport retry from 'async/retry';\nimport waterfall from 'async/waterfall';\nimport JsonRpcError from 'json-rpc-error';\nimport promiseToCallback from 'promise-to-callback';\nimport Subprovider from '../subprovider';\nimport { createPayload } from '../util/create-payload';\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    'Gateway timeout',\n    'ETIMEDOUT',\n    // ignore server sent html error pages\n    // or truncated json responses\n    'SyntaxError',\n    'failed to parse response body',\n    // ignore errors where http req failed to establish\n    'Failed to fetch',\n];\nexport default class FetchSubprovider extends Subprovider {\n    constructor(opts) {\n        super();\n        this.rpcUrl = opts.rpcUrl;\n        this.originHttpHeaderKey = opts.originHttpHeaderKey;\n    }\n    handleRequest(payload, next, end) {\n        const originDomain = payload.origin;\n        // overwrite id to not conflict with other concurrent users\n        const newPayload = this.createPayload(payload);\n        // remove extra parameter from request\n        delete newPayload.origin;\n        const reqParams = {\n            method: 'POST',\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(newPayload),\n        };\n        if (this.originHttpHeaderKey && originDomain) {\n            reqParams.headers[this.originHttpHeaderKey] = originDomain;\n        }\n        retry({\n            times: 5,\n            interval: 1000,\n            errorFilter: isErrorRetriable,\n        }, (cb) => this._submitRequest(reqParams, cb), (err, result) => {\n            // ends on retriable error\n            if (err && isErrorRetriable(err)) {\n                const errMsg = `FetchSubprovider - cannot complete request. All retries exhausted.\\nOriginal Error:\\n${err.toString()}\\n\\n`;\n                const retriesExhaustedErr = new Error(errMsg);\n                return end(retriesExhaustedErr);\n            }\n            // otherwise continue normally\n            return end(err, result);\n        });\n    }\n    createPayload(payload) {\n        return createPayload(payload);\n    }\n    _submitRequest(reqParams, done) {\n        const targetUrl = this.rpcUrl;\n        promiseToCallback(fetch(targetUrl, reqParams))((err, res) => {\n            if (err) {\n                return done(err);\n            }\n            // continue parsing result\n            waterfall([\n                checkForHttpErrors,\n                // buffer body\n                (cb) => promiseToCallback(res.text())(cb),\n                // parse body\n                asyncify((rawBody) => JSON.parse(rawBody)),\n                parseResponse,\n            ], done);\n            function checkForHttpErrors(cb) {\n                // check for errors\n                switch (res.status) {\n                    case 405:\n                        return cb(new JsonRpcError.MethodNotFound());\n                    case 418:\n                        return cb(createRatelimitError());\n                    case 503:\n                    case 504:\n                        return cb(createTimeoutError());\n                    default:\n                        return cb();\n                }\n            }\n            function parseResponse(body, cb) {\n                // check for error code\n                if (res.status !== 200) {\n                    return cb(new JsonRpcError.InternalError(body));\n                }\n                // check for rpc error\n                if (body.error) {\n                    return cb(new JsonRpcError.InternalError(body.error));\n                }\n                // return successful result\n                cb(null, body.result);\n            }\n        });\n    }\n}\nfunction isErrorRetriable(err) {\n    const errMsg = err.toString();\n    return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));\n}\nfunction createRatelimitError() {\n    const msg = 'Request is being rate limited.';\n    const err = new Error(msg);\n    return new JsonRpcError.InternalError(err);\n}\nfunction createTimeoutError() {\n    let msg = 'Gateway timeout. The request took too long to process. ';\n    msg += 'This can happen when querying logs over too wide a block range.';\n    const err = new Error(msg);\n    return new JsonRpcError.InternalError(err);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}