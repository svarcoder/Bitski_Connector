"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _DefaultNetworkStore_networks;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitskiProvider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const provider_error_1 = require("bitski-provider/lib/errors/provider-error");
const network_1 = require("bitski-provider/lib/network");
const jsonrpc_1 = require("./-private/utils/jsonrpc");
const numbers_1 = require("./-private/utils/numbers");
class DefaultNetworkStore {
    constructor() {
        _DefaultNetworkStore_networks.set(this, new Map([
            ['0x1', network_1.Mainnet],
            ['0x5', network_1.Goerli],
            ['0x89', network_1.Polygon],
            ['0x13881', network_1.Mumbai],
            ['0x38', network_1.BinanceSmartChain],
            ['0x61', network_1.BinanceSmartChainTestnet],
        ]));
    }
    async get(chainId) {
        return __classPrivateFieldGet(this, _DefaultNetworkStore_networks, "f").get(chainId);
    }
    async add(chainDetails) {
        const chainId = parseInt(chainDetails.chainId, 16);
        const rpcUrl = chainDetails.rpcUrls[0];
        __classPrivateFieldGet(this, _DefaultNetworkStore_networks, "f").set(chainDetails.chainId, {
            chainId,
            rpcUrl,
        });
    }
}
_DefaultNetworkStore_networks = new WeakMap();
class BitskiProvider extends safe_event_emitter_1.default {
    constructor(sdkPromise, network, options = {}, 
    // Network and network provider store allows multiple instances of
    // BitskiProvider to share state. This is used by the extension so we only
    // have one provider per-chain, but can have different selected providers
    // per page.
    networkStore, networkProviderStore = new Map()) {
        super();
        this.subproviders = [];
        this.subscriptionMap = new Map();
        this.sdkPromise = sdkPromise;
        this.providerOptions = options;
        this.networkStore = networkStore !== null && networkStore !== void 0 ? networkStore : new DefaultNetworkStore();
        this.networkProviderStore = networkProviderStore;
        this.currentProviderPromise = this.setupChain(network);
    }
    get currentBlock() {
        var _a;
        return (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.currentBlock;
    }
    supportsSubscriptions() {
        return !this.providerOptions.disableBlockTracking;
    }
    async subscribe(subscribeMethod, subscriptionMethod, parameters) {
        const provider = await this.currentProviderPromise;
        const subscriptionId = await provider.subscribe(subscribeMethod, subscriptionMethod, parameters);
        this.subscriptionMap.set(subscriptionId, provider);
        return subscriptionId;
    }
    async unsubscribe(subscriptionId, unsubscribeMethod) {
        var _a;
        const provider = this.subscriptionMap.get(subscriptionId);
        const result = await ((_a = provider === null || provider === void 0 ? void 0 : provider.unsubscribe(subscriptionId, unsubscribeMethod)) !== null && _a !== void 0 ? _a : false);
        if (result) {
            this.subscriptionMap.delete(subscriptionId);
        }
        return result;
    }
    isRunning() {
        var _a, _b;
        return (_b = (_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.isRunning()) !== null && _b !== void 0 ? _b : false;
    }
    start() {
        // Wait for the provider promise so we're loaded and bootstrapped
        this.currentProviderPromise.then(() => {
            this.networkProviderStore.forEach((p) => p.start());
        });
    }
    stop() {
        this.currentProviderPromise.then(() => {
            this.networkProviderStore.forEach((p) => p.stop());
        });
    }
    addProvider(source, index) {
        this.currentProviderPromise.then(() => {
            this.networkProviderStore.forEach((p) => p.addProvider(source, index));
        });
        // Save the subprovider to add to new chains if we ever switch chains
        this.subproviders.push([source, index]);
    }
    removeProvider(source) {
        this.currentProviderPromise.then(() => {
            this.networkProviderStore.forEach((p) => p.removeProvider(source));
        });
        // Remove from saved subproviders
        const index = this.subproviders.findIndex((s) => s[0] === source);
        this.subproviders.splice(index, 1);
    }
    async request({ method, params = [] }) {
        if (method === 'wallet_addEthereumChain') {
            return this.addChain(params[0]);
        }
        else if (method === 'wallet_switchEthereumChain') {
            return this.switchChain(params[0]);
        }
        else if (method === 'eth_chainId') {
            await this.currentProviderPromise;
            return this.currentChainId;
        }
        else {
            const provider = await this.currentProviderPromise;
            return provider.send(method, params);
        }
    }
    send(methodOrPayload, paramsOrCallback) {
        if (typeof methodOrPayload !== 'string' && !Array.isArray(paramsOrCallback)) {
            return this.sendAsync(methodOrPayload, paramsOrCallback);
        }
        return this.request({ method: methodOrPayload, params: paramsOrCallback })
            .then((result) => {
            return (0, jsonrpc_1.createResponse)(undefined, result);
        })
            .catch((err) => {
            return (0, jsonrpc_1.createResponse)(err);
        });
    }
    /**
     * @deprecated Please use `.request` instead.
     * @param payload - Request Payload
     */
    sendAsync(payload, callback) {
        this.request(payload)
            .then((response) => {
            callback(null, (0, jsonrpc_1.createResponse)(undefined, response));
        })
            .catch((err) => {
            callback(err);
        });
    }
    async addChain(chainDetails) {
        var _a;
        if (await this.networkStore.get(chainDetails.chainId)) {
            throw new Error('Chain already exists');
        }
        if (!(((_a = chainDetails.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) > 0)) {
            throw new Error('RPC url is required when adding a chain');
        }
        await this.networkStore.add(chainDetails);
        return null;
    }
    async switchChain(chainDetails) {
        const network = await this.networkStore.get(chainDetails.chainId);
        if (!network) {
            throw new provider_error_1.ProviderError('Chain does not exist', 4902);
        }
        this.currentProviderPromise = this.setupChain(network);
        this.emit('chainChanged');
        return null;
    }
    async setupChain(network) {
        let provider = this.networkProviderStore.get(network);
        if (!provider) {
            const sdk = await this.sdkPromise;
            if (!sdk) {
                throw new Error('Bitski SDK not available');
            }
            provider = sdk.createProvider(network, this.providerOptions);
            // Add all previously added providers to the new chain
            for (const [subprovider, index] of this.subproviders) {
                provider.addProvider(subprovider, index);
            }
            // Override provider emit so it emits directly to the wrapper/loader
            provider.emit = this.emit.bind(this);
            this.networkProviderStore.set(network, provider);
            provider.start();
        }
        // Set current provider so we can access it for non-async values
        this.currentProvider = provider;
        this.currentChainId = (0, numbers_1.toHex)(network.chainId);
        return provider;
    }
}
exports.BitskiProvider = BitskiProvider;
//# sourceMappingURL=provider.js.map