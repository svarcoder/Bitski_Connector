import { Subprovider } from '@bitski/provider-engine';
import { AccessTokenProvider, JSONRPCRequestPayload, Network } from 'bitski-provider';
import JsonRpcError from 'json-rpc-error';
import { BitskiTransactionSigner } from '../signing/transaction-signer';
declare type JSONRPCResponseHandler = (error?: JsonRpcError, result?: any) => void;
export declare enum TransactionKind {
    SendTransaction = "ETH_SEND_TRANSACTION",
    SignTransaction = "ETH_SIGN_TRANSACTION",
    Sign = "ETH_SIGN",
    SignTypedData = "ETH_SIGN_TYPED_DATA",
    SignTypedDataV3 = "ETH_SIGN_TYPED_DATA_V3",
    SignTypedDataV4 = "ETH_SIGN_TYPED_DATA_V4"
}
export interface Transaction {
    id: string;
    kind: TransactionKind;
    payload: TransactionPayload | SignaturePayload;
    context: TransactionContext;
}
export interface TransactionContext {
    chainId?: number;
    currentBalance?: string;
    from?: string;
}
export interface SignaturePayload {
    from: string;
    message: string;
}
export interface TransactionPayload {
    from: string;
    to?: string;
    value?: string;
    data?: string;
    nonce?: string;
    gas?: string;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    type?: string;
}
export interface TypedDataDefinition {
    name: string;
    type: string;
}
/**
 * Example usage:
 * ```javascript
 * const payload: TypedDataPayload = {
 *   types: {
 *     EIP712Domain: [
 *       { name: 'name', type: 'string' },
 *       { name: 'version', type: 'string' },
 *       { name: 'chainId', type: 'uint256' },
 *       { name: 'verifyingContract', type: 'address' },
 *     ],
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' }
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' }
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * }
 * ```
 */
export interface TypedDataPayload {
    types: {
        EIP712Domain: TypedDataDefinition[];
        [propName: string]: TypedDataDefinition[];
    };
    domain: Record<string, unknown>;
    primaryType: string;
    message: Record<string, unknown>;
}
/**
 * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.
 * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.
 * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.
 *
 * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider
 * should be placed in front of this subprovider.
 */
export declare class SignatureSubprovider extends Subprovider {
    protected network: Network;
    protected tokenProvider: AccessTokenProvider;
    protected signer: BitskiTransactionSigner;
    protected signatureMethods: string[];
    constructor(network: Network, signer: BitskiTransactionSigner, tokenProvider: AccessTokenProvider, signatureMethods?: string[]);
    /**
     * Handle RPC request from engine (called by)
     * @param payload RPC request payload
     * @param next Callback to skip handling this request
     * @param end Completion handler
     */
    handleRequest(payload: JSONRPCRequestPayload, next: () => void, end: JSONRPCResponseHandler): void;
    /**
     * Called when a payload is received that needs a signature
     * @param payload The JSON-RPC request
     * @param callback The callback to call when the request has been handled
     */
    handleSignatureRequest(payload: JSONRPCRequestPayload, callback: JSONRPCResponseHandler): Promise<void>;
    /** Should this subprovider handle the request?
     * @param method The RPC method of the request
     */
    protected requiresSignature(method: string): boolean;
    /**
     * This will forward transactions that should be automatically submitted to the network, otherwise
     * resolve with the original value.
     * @param payload The original request payload
     * @param signedData signed data for the transaction
     */
    protected sendIfNeeded(payload: JSONRPCRequestPayload, signedData: string): Promise<any>;
    /**
     * Load the balance so the web approval dialog can give the user better context
     * @param payload Payload for the request
     */
    protected loadBalanceIfNeeded(payload: JSONRPCRequestPayload): Promise<any>;
    /**
     * Responsible for creating the Transaction object from a given RPC payload
     * @param payload JSON-RPC payload to extract the values from
     */
    protected createBitskiTransaction(payload: JSONRPCRequestPayload): Promise<Transaction>;
    private createContext;
    /**
     * Responsible for creating the payload from a given RPC request
     * @param request JSON-RPC request to extract params from
     */
    private createPayload;
    /**
     * Determines a BitskiTransaction.Kind value from a given RPC method name
     * @param method The JSON-RPC method being requested
     */
    private kindForMethod;
    private performRequest;
}
export {};
