"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestFetchSubprovider = void 0;
const provider_engine_1 = require("@bitski/provider-engine");
const asyncify_1 = __importDefault(require("async/asyncify"));
const retry_1 = __importDefault(require("async/retry"));
const waterfall_1 = __importDefault(require("async/waterfall"));
const json_rpc_error_1 = __importDefault(require("json-rpc-error"));
const promise_to_callback_1 = __importDefault(require("promise-to-callback"));
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
const MATCHING_METHODS = ['eth_getBlockByNumber', 'eth_blockNumber', 'net_Version', 'eth_getLogs'];
class RestFetchSubprovider extends provider_engine_1.Subprovider {
    constructor(opts) {
        super();
        this.rpcUrl = opts.rpcUrl;
        this.defaultHeaders = opts.defaultHeaders;
        this.originHttpHeaderKey = opts.originHttpHeaderKey;
    }
    handleRequest(payload, next, end) {
        if (MATCHING_METHODS.includes(payload.method)) {
            this.handleRestRequest(payload, end);
        }
        else {
            next();
        }
    }
    handleRestRequest(payload, end) {
        const originDomain = payload.origin;
        const query = payload.params.length > 0
            ? `?params=${encodeURIComponent(JSON.stringify(payload.params))}`
            : '';
        const url = `${this.rpcUrl}/${payload.method}${query}`;
        const reqParams = {
            method: 'GET',
            headers: Object.assign({
                Accept: 'application/json',
                'Content-Type': 'application/json',
            }, this.defaultHeaders),
            credentials: 'omit',
        };
        if (this.originHttpHeaderKey && originDomain) {
            reqParams.headers[this.originHttpHeaderKey] = originDomain;
        }
        (0, retry_1.default)({
            times: 5,
            interval: 1000,
            errorFilter: isErrorRetriable,
        }, (cb) => this._submitRequest(url, reqParams, cb), (err, result) => {
            // ends on retriable error
            if (err && isErrorRetriable(err)) {
                const errMsg = `FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err.toString()}\n\n`;
                const retriesExhaustedErr = new Error(errMsg);
                return end(retriesExhaustedErr);
            }
            // otherwise continue normally
            return end(err, result);
        });
    }
    _submitRequest(targetUrl, reqParams, done) {
        (0, promise_to_callback_1.default)(fetch(targetUrl, reqParams))((err, res) => {
            if (err) {
                return done(err);
            }
            // continue parsing result
            (0, waterfall_1.default)([
                checkForHttpErrors,
                // buffer body
                (cb) => (0, promise_to_callback_1.default)(res.text())(cb),
                // parse body
                (0, asyncify_1.default)((rawBody) => JSON.parse(rawBody)),
                parseResponse,
            ], done);
            function checkForHttpErrors(cb) {
                // check for errors
                switch (res.status) {
                    case 405:
                        return cb(new json_rpc_error_1.default.MethodNotFound());
                    case 418:
                        return cb(createRatelimitError());
                    case 503:
                    case 504:
                        return cb(createTimeoutError());
                    default:
                        return cb();
                }
            }
            function parseResponse(body, cb) {
                // check for error code
                if (res.status !== 200) {
                    return cb(new json_rpc_error_1.default.InternalError(body));
                }
                cb(null, body);
            }
        });
    }
}
exports.RestFetchSubprovider = RestFetchSubprovider;
function isErrorRetriable(err) {
    const errMsg = err.toString();
    return RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
}
function createRatelimitError() {
    const msg = 'Request is being rate limited.';
    const err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}
function createTimeoutError() {
    let msg = 'Gateway timeout. The request took too long to process. ';
    msg += 'This can happen when querying logs over too wide a block range.';
    const err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}
//# sourceMappingURL=rest-fetch.js.map