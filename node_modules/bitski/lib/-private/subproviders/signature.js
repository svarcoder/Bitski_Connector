"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureSubprovider = exports.TransactionKind = void 0;
const provider_engine_1 = require("@bitski/provider-engine");
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const signer_error_1 = require("../errors/signer-error");
var TransactionKind;
(function (TransactionKind) {
    TransactionKind["SendTransaction"] = "ETH_SEND_TRANSACTION";
    TransactionKind["SignTransaction"] = "ETH_SIGN_TRANSACTION";
    TransactionKind["Sign"] = "ETH_SIGN";
    TransactionKind["SignTypedData"] = "ETH_SIGN_TYPED_DATA";
    TransactionKind["SignTypedDataV3"] = "ETH_SIGN_TYPED_DATA_V3";
    TransactionKind["SignTypedDataV4"] = "ETH_SIGN_TYPED_DATA_V4";
})(TransactionKind = exports.TransactionKind || (exports.TransactionKind = {}));
/**
 * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.
 * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.
 * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.
 *
 * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider
 * should be placed in front of this subprovider.
 */
class SignatureSubprovider extends provider_engine_1.Subprovider {
    constructor(network, signer, tokenProvider, signatureMethods) {
        super();
        this.network = network;
        this.tokenProvider = tokenProvider;
        this.signer = signer;
        this.signatureMethods = signatureMethods || constants_1.DEFAULT_AUTHORIZED_METHODS;
    }
    /**
     * Handle RPC request from engine (called by)
     * @param payload RPC request payload
     * @param next Callback to skip handling this request
     * @param end Completion handler
     */
    handleRequest(payload, next, end) {
        if (this.requiresSignature(payload.method)) {
            this.handleSignatureRequest(payload, end);
            return;
        }
        next();
    }
    /**
     * Called when a payload is received that needs a signature
     * @param payload The JSON-RPC request
     * @param callback The callback to call when the request has been handled
     */
    async handleSignatureRequest(payload, callback) {
        try {
            // Get access token
            const accessToken = await this.tokenProvider.getAccessToken();
            // Prepare a transaction object
            const transaction = await this.createBitskiTransaction(payload);
            // Sign the transaction object
            const signedResponse = await this.signer.sign(transaction, accessToken);
            // Send the transaction if needed
            const result = await this.sendIfNeeded(payload, signedResponse);
            // Call the callback with the result
            callback(undefined, result);
        }
        catch (error) {
            // Call with the error if any of the steps fail
            callback(error, undefined);
        }
    }
    /** Should this subprovider handle the request?
     * @param method The RPC method of the request
     */
    requiresSignature(method) {
        return this.signatureMethods.includes(method);
    }
    /**
     * This will forward transactions that should be automatically submitted to the network, otherwise
     * resolve with the original value.
     * @param payload The original request payload
     * @param signedData signed data for the transaction
     */
    sendIfNeeded(payload, signedData) {
        if (payload.method === 'eth_sendTransaction') {
            // Create a send raw transaction payload
            const sendPayload = {
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_sendRawTransaction',
                params: [signedData],
            };
            return this.performRequest(sendPayload);
        }
        return Promise.resolve(signedData);
    }
    /**
     * Load the balance so the web approval dialog can give the user better context
     * @param payload Payload for the request
     */
    loadBalanceIfNeeded(payload) {
        // Only necessary if this is a transaction
        const isTransaction = payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction';
        const isCustomRPC = !this.network.rpcUrl.includes('api.bitski.com');
        if (isTransaction && isCustomRPC) {
            const transaction = payload.params[0];
            const balancePayload = {
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_getBalance',
                params: [transaction.from, 'latest'],
            };
            return this.performRequest(balancePayload);
        }
        return Promise.resolve();
    }
    /**
     * Responsible for creating the Transaction object from a given RPC payload
     * @param payload JSON-RPC payload to extract the values from
     */
    async createBitskiTransaction(payload) {
        const context = await this.createContext(payload);
        const kind = this.kindForMethod(payload.method);
        const extractedPayload = this.createPayload(payload);
        const transaction = {
            id: (0, uuid_1.v4)(),
            kind,
            payload: extractedPayload,
            context,
        };
        return transaction;
    }
    async createContext(request) {
        switch (request.method) {
            case 'personal_sign':
            case 'eth_sign':
            case 'eth_sendTransaction':
            case 'eth_signTransaction': {
                const balance = await this.loadBalanceIfNeeded(request);
                if (balance) {
                    return { chainId: this.network.chainId, currentBalance: balance };
                }
                return { chainId: this.network.chainId };
            }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v3':
            case 'eth_signTypedData_v4':
                // The from address should be the first parameter as a 20 byte hex string
                if (request.params && request.params.length > 0) {
                    return { from: request.params[0] };
                }
                throw signer_error_1.SignerError.MissingFrom();
            default:
                // Other transaction types do not need context
                return {};
        }
    }
    /**
     * Responsible for creating the payload from a given RPC request
     * @param request JSON-RPC request to extract params from
     */
    createPayload(request) {
        switch (request.method) {
            case 'eth_sendTransaction':
            case 'eth_signTransaction':
                if (request.params && request.params.length > 0) {
                    return request.params[0];
                }
                else {
                    throw signer_error_1.SignerError.MissingTransaction();
                }
            case 'eth_sign':
                if (request.params && request.params.length > 1) {
                    return { from: request.params[0], message: request.params[1] };
                }
                else {
                    throw signer_error_1.SignerError.MissingMessage();
                }
            case 'personal_sign':
                if (request.params && request.params.length > 1) {
                    // If the first param is a wallet address, flip the parameter ordering for personal_sign
                    // so that it matches eth_sign. This is to gracefully respect Dapps who adopted Metamask's
                    // API for personal_sign early, and recover from the wrong param order
                    // when it is clearly identifiable.
                    if (request.params[0].startsWith('0x') && request.params[0].length === 42) {
                        return { from: request.params[0], message: request.params[1] };
                    }
                    return { from: request.params[1], message: request.params[0] };
                }
                else {
                    throw signer_error_1.SignerError.MissingMessage();
                }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v3':
            case 'eth_signTypedData_v4':
                if (request.params && request.params.length > 1) {
                    return request.params[1];
                }
                else {
                    throw signer_error_1.SignerError.MissingTypedData();
                }
            default:
                throw signer_error_1.SignerError.UnsupportedMethod();
        }
    }
    /**
     * Determines a BitskiTransaction.Kind value from a given RPC method name
     * @param method The JSON-RPC method being requested
     */
    kindForMethod(method) {
        switch (method) {
            case 'eth_sendTransaction':
            case 'eth_signTransaction':
                // Convert both *sign* and *send* methods into a sign transaction.
                // (we will forward the transaction locally if needed)
                return TransactionKind.SignTransaction;
            case 'eth_sign':
            case 'personal_sign':
                return TransactionKind.Sign;
            case 'eth_signTypedData':
                return TransactionKind.SignTypedData;
            case 'eth_signTypedData_v3':
                return TransactionKind.SignTypedDataV3;
            case 'eth_signTypedData_v4':
                return TransactionKind.SignTypedDataV4;
            default:
                throw signer_error_1.SignerError.UnsupportedMethod();
        }
    }
    // Wraps emitPayload in a promise
    performRequest(payload) {
        return new Promise((fulfill, reject) => {
            this.emitPayload(payload, (err, result) => {
                if (err) {
                    reject(err);
                }
                else {
                    fulfill(result.result);
                }
            });
        });
    }
}
exports.SignatureSubprovider = SignatureSubprovider;
//# sourceMappingURL=signature.js.map