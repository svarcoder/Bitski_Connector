"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitskiBrowserEngine = void 0;
const bitski_provider_1 = require("bitski-provider");
const constants_1 = require("../constants");
const transaction_signer_1 = require("../signing/transaction-signer");
const authenticated_cache_1 = require("../subproviders/authenticated-cache");
const remote_accounts_1 = require("../subproviders/remote-accounts");
const rest_fetch_1 = require("../subproviders/rest-fetch");
const signature_1 = require("../subproviders/signature");
// Predicate to determine if the token provider is an AuthProvider
function isAuthProvider(object) {
    return object.getUser !== undefined;
}
class BitskiBrowserEngine extends bitski_provider_1.BitskiEngine {
    constructor(clientId, tokenProvider, sdkVersion, network, options = {}, 
    // This allows the extension to sub out a different signer class
    TransactionSignerClass = transaction_signer_1.BitskiTransactionSigner) {
        super(options);
        options = options || {};
        this.network = network;
        this.clientId = clientId;
        this.sdkVersion = sdkVersion;
        this.apiBaseUrl = options.apiBaseUrl || constants_1.BITSKI_TRANSACTION_API_BASE_URL;
        this.webBaseUrl = options.webBaseUrl || constants_1.BITSKI_WEB_BASE_URL;
        this.tokenProvider = tokenProvider;
        const defaultBitskiHeaders = {
            'X-API-KEY': this.clientId,
            'X-CLIENT-ID': this.clientId,
            'X-CLIENT-VERSION': this.sdkVersion,
        };
        this.headers = defaultBitskiHeaders;
        this.rpcHeaders = {};
        if (options && options.additionalHeaders) {
            this.headers = Object.assign({}, options.additionalHeaders, this.headers);
            this.rpcHeaders = options.additionalHeaders;
        }
        if (this.network && this.network.rpcUrl.includes('bitski.com')) {
            this.rpcHeaders = Object.assign({}, this.rpcHeaders, defaultBitskiHeaders);
        }
        this.signer = new TransactionSignerClass(this.webBaseUrl, this.apiBaseUrl, this.headers, options.callbackURL);
        this.addSubproviders();
    }
    addSubproviders() {
        // Used for eth_accounts calls
        const accountsProvider = new remote_accounts_1.RemoteAccountSubprovider(`${constants_1.BITSKI_RPC_BASE_URL}/mainnet`, false, this.tokenProvider, this.headers);
        // Used for all other calls
        const fetchSubprovider = new bitski_provider_1.AuthenticatedFetchSubprovider(this.network.rpcUrl, false, this.tokenProvider, this.rpcHeaders);
        // Respond to some requests via userinfo object if available
        if (isAuthProvider(this.tokenProvider)) {
            const cacheSubprovider = new authenticated_cache_1.AuthenticatedCacheSubprovider(this.tokenProvider, this);
            this.addProvider(cacheSubprovider);
        }
        // Ensure that whenever accounts are requested, they go through Bitski
        this.addProvider(accountsProvider);
        // Respond to requests that need signed with an iframe
        const signatureSubprovider = new signature_1.SignatureSubprovider(this.network, this.signer, this.tokenProvider);
        this.addProvider(signatureSubprovider);
        // Respond to block request via REST is using Bitski RPC endpoint
        if (this.network.rpcUrl.startsWith('https://api.bitski.com')) {
            const blockProvider = new rest_fetch_1.RestFetchSubprovider({
                rpcUrl: this.network.rpcUrl,
                defaultHeaders: this.headers,
            });
            this.addProvider(blockProvider);
        }
        // Finally, add our basic HTTP provider
        this.addProvider(fetchSubprovider);
    }
}
exports.BitskiBrowserEngine = BitskiBrowserEngine;
//# sourceMappingURL=bitski-browser-engine.js.map