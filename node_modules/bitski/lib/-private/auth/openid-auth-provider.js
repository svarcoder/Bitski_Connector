"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenidAuthProvider = void 0;
const constants_1 = require("../constants");
const authentication_error_1 = require("../errors/authentication-error");
const oauth_manager_1 = require("./oauth-manager");
const token_store_1 = require("./token-store");
const user_1 = require("./user");
const user_store_1 = require("./user-store");
class OpenidAuthProvider {
    constructor(clientId, redirectUri, additionalScopes, opts) {
        opts = opts || {};
        const settings = {
            additionalScopes,
            clientId,
            redirectUri,
        };
        Object.assign(settings, opts);
        this.oauthManager = new oauth_manager_1.OAuthManager(settings);
        this.tokenStore = new token_store_1.TokenStore(clientId, opts.store);
        this.userStore = new user_store_1.UserStore(clientId, opts.store);
    }
    async getAuthStatus() {
        if (await this.tokenStore.getCurrentToken()) {
            return constants_1.AuthenticationStatus.Connected;
        }
        else if (await this.tokenStore.getRefreshToken()) {
            return constants_1.AuthenticationStatus.Expired;
        }
        else {
            return constants_1.AuthenticationStatus.NotConnected;
        }
    }
    async getAccessToken() {
        const currentToken = await this.tokenStore.getCurrentToken();
        if (currentToken) {
            return currentToken;
        }
        if (await this.tokenStore.getRefreshToken()) {
            return this.refreshAccessToken();
        }
        throw authentication_error_1.AuthenticationError.NotSignedIn();
    }
    async getIdToken() {
        const currentIdToken = await this.tokenStore.getCurrentToken();
        if (currentIdToken) {
            return currentIdToken;
        }
        if (await this.tokenStore.getRefreshToken()) {
            return this.refreshIdToken();
        }
        return Promise.reject(authentication_error_1.AuthenticationError.NotSignedIn());
    }
    async getRefreshToken() {
        const refreshToken = await this.tokenStore.getRefreshToken();
        if (refreshToken) {
            return refreshToken;
        }
        // Error: the user did not approve this app for offline access
        if (await this.tokenStore.getCurrentToken()) {
            return Promise.reject(authentication_error_1.AuthenticationError.NoRefreshToken());
        }
        // Error: the user is not signed in.
        return Promise.reject(authentication_error_1.AuthenticationError.NotSignedIn());
    }
    async invalidateToken() {
        await this.tokenStore.invalidateCurrentToken();
        if (this.signOutCallback) {
            this.signOutCallback();
        }
    }
    refreshTokens() {
        if (!this._refreshTokensPromise) {
            this._refreshTokensPromise = this.tokenStore.getRefreshToken().then(async (refreshToken) => {
                if (!refreshToken) {
                    throw authentication_error_1.AuthenticationError.NoRefreshToken();
                }
                try {
                    const tokenResponse = await this.oauthManager.refreshAccessToken(refreshToken);
                    this.tokenStore.persistTokenResponse(tokenResponse);
                    return tokenResponse;
                }
                catch (error) {
                    await this.tokenStore.clear();
                    await this.userStore.clear();
                    throw error;
                }
                finally {
                    this._refreshTokensPromise = undefined;
                }
            });
        }
        return this._refreshTokensPromise;
    }
    async refreshAccessToken() {
        const tokenResponse = await this.refreshTokens();
        return tokenResponse.accessToken;
    }
    async refreshIdToken() {
        const tokenResponse = await this.refreshTokens();
        return tokenResponse.idToken;
    }
    signIn(method, opts) {
        let promise;
        switch (method) {
            case constants_1.OAuthSignInMethod.Redirect:
                promise = this.oauthManager.signInRedirect(opts);
                break;
            case constants_1.OAuthSignInMethod.Silent:
                return Promise.reject(authentication_error_1.AuthenticationError.UnsupportedAuthenticationMethod());
            default:
                promise = this.oauthManager.signInPopup(opts);
                break;
        }
        return promise.then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    connect() {
        return this.refreshAccessToken().then(() => {
            return this.loadUser();
        });
    }
    getUser() {
        return this.getOrFetchUser();
    }
    async signInOrConnect(signInMethod = constants_1.OAuthSignInMethod.Popup, opts) {
        switch (await this.getAuthStatus()) {
            case constants_1.AuthenticationStatus.Connected:
                return this.loadUser();
            case constants_1.AuthenticationStatus.Expired:
                return this.connect();
            case constants_1.AuthenticationStatus.NotConnected:
                return this.signIn(signInMethod, opts);
        }
    }
    redirectCallback() {
        return this.oauthManager.redirectCallback().then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    async signOut() {
        await this.tokenStore.clear();
        await this.userStore.clear();
        // Call the sign out callback if one has been provided
        if (this.signOutCallback) {
            this.signOutCallback();
        }
        // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
        // Down the road this may perform a network request to invalidate.
        return Promise.resolve();
    }
    async getOrFetchUser() {
        const currentUser = await this.userStore.getCurrentUser();
        if (currentUser) {
            return currentUser;
        }
        return this.loadUser();
    }
    loadUser() {
        return this.getAccessToken()
            .then((accessToken) => {
            return this.oauthManager.requestUserInfo(accessToken);
        })
            .then((json) => {
            return user_1.User.fromJson(json);
        })
            .then((user) => {
            this.userStore.set(user);
            return user;
        });
    }
    loadFromCache() {
        this.tokenStore.loadTokensFromCache();
        this.userStore.loadUserFromCache();
    }
}
exports.OpenidAuthProvider = OpenidAuthProvider;
//# sourceMappingURL=openid-auth-provider.js.map