"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthManager = exports.LOGIN_HINT_SIGNUP = void 0;
const appauth_1 = require("@openid/appauth");
const constants_1 = require("../constants");
const authentication_error_1 = require("../errors/authentication-error");
const no_hash_query_string_utils_1 = require("../utils/no-hash-query-string-utils");
const request_utils_1 = require("../utils/request-utils");
const popup_handler_1 = require("./popup-handler");
// Use this constant in login_hint to indicate that the sign up UI should be displayed
exports.LOGIN_HINT_SIGNUP = 'signup';
/**
 * Responsible for submitting requests to our OAuth server.
 */
class OAuthManager {
    /**
     * Create a new OAuth Manager
     * @param options Settings object
     * @param options.clientId string: The client id to use for various requests
     * @param options.redirectUri string: The redirect URI to use for responding to auth requests
     * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server
     * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.
     * Default is offline. Pass an empty array to only request openid.
     */
    constructor(options) {
        this.clientId = options.clientId;
        this.redirectUri = options.redirectUri;
        this.configuration =
            options.configuration || new appauth_1.AuthorizationServiceConfiguration(constants_1.DEFAULT_OAUTH_CONFIGURATION);
        const additionalScopes = options.additionalScopes || constants_1.DEFAULT_OPTIONAL_SCOPES;
        this.scopes = constants_1.DEFAULT_SCOPES.concat(additionalScopes);
        this.tokenHandler = new appauth_1.BaseTokenRequestHandler(new appauth_1.FetchRequestor());
        this.notifier = new appauth_1.AuthorizationNotifier();
        this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));
    }
    /**
     * Trigger a popup sign in flow (the default)
     */
    signInPopup(opts) {
        opts = opts || {};
        const promise = new Promise((fulfill, reject) => {
            this.pendingResolver = { fulfill, reject };
        });
        this.authHandler = new popup_handler_1.PopupRequestHandler();
        this.authHandler.setAuthorizationNotifier(this.notifier);
        const request = this.createAuthRequest(opts);
        this.authHandler.performAuthorizationRequest(this.configuration, request);
        return promise.then((response) => {
            return this.requestAccessToken(response.code);
        });
    }
    /**
     * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.
     */
    signInRedirect(opts) {
        opts = opts || {};
        const promise = new Promise((fulfill, reject) => {
            this.pendingResolver = { fulfill, reject };
        });
        this.authHandler = new appauth_1.RedirectRequestHandler(undefined, new no_hash_query_string_utils_1.NoHashQueryStringUtils());
        this.authHandler.setAuthorizationNotifier(this.notifier);
        const request = this.createAuthRequest(opts);
        this.authHandler.performAuthorizationRequest(this.configuration, request);
        // Since this method redirects the whole window, the promise will
        // likely never complete unless we encounter an error.
        return promise;
    }
    /**
     * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been
     * redirected back.
     */
    redirectCallback() {
        const promise = new Promise((fulfill, reject) => {
            this.pendingResolver = { fulfill, reject };
        });
        this.authHandler = new appauth_1.RedirectRequestHandler(undefined, new no_hash_query_string_utils_1.NoHashQueryStringUtils());
        this.authHandler.setAuthorizationNotifier(this.notifier);
        this.authHandler.completeAuthorizationRequestIfPossible();
        return promise.then((response) => {
            return this.requestAccessToken(response.code);
        });
    }
    /**
     * Exchange an authorization code for an access token
     * @param code The authorization code to exchange
     */
    requestAccessToken(code) {
        const request = this.createTokenRequest(code);
        return this.tokenHandler.performTokenRequest(this.configuration, request);
    }
    /**
     * Request a new access token from a previous refresh token
     * @param refreshToken The refresh token to use for authorization
     */
    refreshAccessToken(refreshToken) {
        const request = this.createRefreshTokenRequest(refreshToken);
        return this.tokenHandler.performTokenRequest(this.configuration, request);
    }
    /**
     * Submit a sign out request on the oauth endpoint
     * @param accessToken The access token to sign out with
     */
    requestSignOut(accessToken) {
        return fetch(`${constants_1.BITSKI_USER_API_HOST}/logout`, {
            headers: {
                Accept: 'application/json',
                Authorization: `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            },
            method: 'POST',
        }).then((response) => {
            return (0, request_utils_1.parseResponse)(response);
        });
    }
    /**
     * Request a user's profile from the oauth server
     * @param accessToken The access token for the user
     */
    requestUserInfo(accessToken) {
        const userInfoEndpoint = this.configuration.userInfoEndpoint;
        if (!userInfoEndpoint) {
            return Promise.reject(authentication_error_1.AuthenticationError.InvalidConfiguration('Could not find user info endpoint'));
        }
        return fetch(userInfoEndpoint, {
            headers: {
                Accept: 'application/json',
                Authorization: `Bearer ${accessToken}`,
            },
        }).then((response) => {
            return (0, request_utils_1.parseResponse)(response);
        });
    }
    /**
     * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.
     * @param request The original auth request
     * @param response The auth response if it was successful
     * @param errorResponse The error response if it failed
     */
    didCompleteAuthorizationFlow(request, response, errorResponse) {
        if (this.pendingResolver) {
            if (response) {
                this.pendingResolver.fulfill(response);
                this.pendingResolver = undefined;
            }
            else if (errorResponse) {
                if (errorResponse instanceof popup_handler_1.PopupClosedError) {
                    this.pendingResolver.reject(authentication_error_1.AuthenticationError.UserCancelled());
                }
                else if (errorResponse instanceof popup_handler_1.PopupBlockedError) {
                    // Parse domain of the authority, to log better context for error.
                    const urlMatch = /^(http?s:\/\/[\w.]*)\/[\w/]*$/;
                    // Check for matches against the authority
                    const matches = this.configuration.authorizationEndpoint.match(urlMatch);
                    const baseUrl = matches && matches.length > 1 ? matches[1] : '';
                    this.pendingResolver.reject(authentication_error_1.AuthenticationError.PopupBlocked(baseUrl));
                }
                else {
                    this.pendingResolver.reject(authentication_error_1.AuthenticationError.ServerError(errorResponse.error, errorResponse.errorDescription));
                }
                this.pendingResolver = undefined;
            }
        }
    }
    /**
     * Factory method to create an auth request
     */
    createAuthRequest(opts) {
        // Create base request
        const request = new appauth_1.AuthorizationRequest({
            client_id: this.clientId,
            redirect_uri: this.redirectUri,
            response_type: appauth_1.AuthorizationRequest.RESPONSE_TYPE_CODE,
            scope: this.scopes.join(' '),
        }, undefined, false);
        // Pass options through
        if (opts.login_hint) {
            // Only assign extras if login_hint is included in the options
            request.extras = { login_hint: opts.login_hint };
        }
        return request;
    }
    /**
     * Factory method to create a token request with a refresh token
     * @param refreshToken Refresh token to use
     */
    createRefreshTokenRequest(refreshToken) {
        return new appauth_1.TokenRequest({
            client_id: this.clientId,
            grant_type: appauth_1.GRANT_TYPE_REFRESH_TOKEN,
            redirect_uri: this.redirectUri,
            refresh_token: refreshToken,
        });
    }
    /**
     * Factory method to create a token request with an auth code
     * @param code The auth code to use
     */
    createTokenRequest(code) {
        return new appauth_1.TokenRequest({
            client_id: this.clientId,
            code,
            grant_type: appauth_1.GRANT_TYPE_AUTHORIZATION_CODE,
            redirect_uri: this.redirectUri,
        });
    }
}
exports.OAuthManager = OAuthManager;
//# sourceMappingURL=oauth-manager.js.map