"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOGIN_HINT_SIGNUP = exports.Bitski = exports.OAuthSignInMethod = exports.AuthenticationStatus = exports.Mumbai = exports.Polygon = exports.Goerli = exports.Mainnet = exports.BinanceSmartChainTestnet = exports.BinanceSmartChain = exports.SignerErrorCode = exports.SignerError = exports.ParseErrorCode = exports.ParseError = exports.AuthenticationErrorCode = exports.AuthenticationError = void 0;
const callback_1 = require("./-private/utils/callback");
const load_1 = require("./load");
const provider_1 = require("./provider");
const connect_button_1 = require("./-private/components/connect-button");
const constants_1 = require("./-private/constants");
Object.defineProperty(exports, "AuthenticationStatus", { enumerable: true, get: function () { return constants_1.AuthenticationStatus; } });
Object.defineProperty(exports, "OAuthSignInMethod", { enumerable: true, get: function () { return constants_1.OAuthSignInMethod; } });
// Import these directly so we don't load the whole provider bundle
const network_1 = require("bitski-provider/lib/network");
Object.defineProperty(exports, "BinanceSmartChain", { enumerable: true, get: function () { return network_1.BinanceSmartChain; } });
Object.defineProperty(exports, "BinanceSmartChainTestnet", { enumerable: true, get: function () { return network_1.BinanceSmartChainTestnet; } });
Object.defineProperty(exports, "Goerli", { enumerable: true, get: function () { return network_1.Goerli; } });
Object.defineProperty(exports, "Mainnet", { enumerable: true, get: function () { return network_1.Mainnet; } });
Object.defineProperty(exports, "Mumbai", { enumerable: true, get: function () { return network_1.Mumbai; } });
Object.defineProperty(exports, "Polygon", { enumerable: true, get: function () { return network_1.Polygon; } });
const bitski_provider_1 = require("bitski-provider");
const numbers_1 = require("./-private/utils/numbers");
var authentication_error_1 = require("./-private/errors/authentication-error");
Object.defineProperty(exports, "AuthenticationError", { enumerable: true, get: function () { return authentication_error_1.AuthenticationError; } });
Object.defineProperty(exports, "AuthenticationErrorCode", { enumerable: true, get: function () { return authentication_error_1.AuthenticationErrorCode; } });
var parse_error_1 = require("./-private/errors/parse-error");
Object.defineProperty(exports, "ParseError", { enumerable: true, get: function () { return parse_error_1.ParseError; } });
Object.defineProperty(exports, "ParseErrorCode", { enumerable: true, get: function () { return parse_error_1.ParseErrorCode; } });
var signer_error_1 = require("./-private/errors/signer-error");
Object.defineProperty(exports, "SignerError", { enumerable: true, get: function () { return signer_error_1.SignerError; } });
Object.defineProperty(exports, "SignerErrorCode", { enumerable: true, get: function () { return signer_error_1.SignerErrorCode; } });
class Bitski {
    /**
     * @param clientId OAuth Client ID
     * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
     * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
     * Note: Make sure your app is approved for the scopes you are requesting first.
     * @param options Other OAuth settings. Don't change these unless you know what you are doing.
     */
    constructor(clientId, redirectUri, additionalScopes, options) {
        this.sdk = (0, load_1.loadScript)().then((BitskiSDK) => {
            return BitskiSDK ? new BitskiSDK(clientId, redirectUri, additionalScopes, options) : null;
        });
    }
    /**
     * Alternative to using our static callback.html file. Call this from your own redirect page.
     */
    static callback() {
        (0, callback_1.processCallback)();
    }
    /**
     * Returns a new web3 provider for a given network.
     * @param options options for the provider, or a network name
     */
    getProvider(options) {
        var _a;
        if (typeof window !== 'undefined' && ((_a = window.Bitski) === null || _a === void 0 ? void 0 : _a.getProvider)) {
            return window.Bitski.getProvider(options);
        }
        const network = networkFromProviderOptions(options);
        if (!this.provider) {
            this.provider = new provider_1.BitskiProvider(this.sdk, network !== null && network !== void 0 ? network : network_1.Mainnet, typeof options === 'string' ? undefined : options);
        }
        else if (network) {
            this.provider
                .request({
                method: 'wallet_switchChain',
                params: [{ chainId: (0, numbers_1.toHex)(network.chainId) }],
            })
                .catch(async (error) => {
                var _a, _b;
                if (error.code === bitski_provider_1.ProviderErrorCode.ChainDoesNotExist) {
                    await ((_a = this.provider) === null || _a === void 0 ? void 0 : _a.request({
                        method: 'wallet_addChain',
                        params: [
                            {
                                chainId: (0, numbers_1.toHex)(network.chainId),
                                rpcUrls: [network.rpcUrl],
                            },
                        ],
                    }));
                    await ((_b = this.provider) === null || _b === void 0 ? void 0 : _b.request({
                        method: 'wallet_switchChain',
                        params: [{ chainId: (0, numbers_1.toHex)(network.chainId) }],
                    }));
                }
            });
            this.provider.start();
        }
        return this.provider;
    }
    /**
     * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
     * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
     * a callback to get notified of login events.
     * @param options {ConnectButtonOptions} Optional configuration for the button
     * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
     */
    getConnectButton(options, callback) {
        return new connect_button_1.ConnectButton(this.sdk, options, callback);
    }
    /**
     * Signs in or connects to bitski depending on the user's auth state.
     * Since it may open a popup, this method must be called from user interaction handler,
     * such as a click or tap handler.
     * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
     */
    async start(options) {
        return this.getSDK().then((sdk) => sdk.signInOrConnect(undefined, options));
    }
    /**
     * Check the logged in state of the user
     */
    async getAuthStatus() {
        return this.getSDK().then((sdk) => sdk.getAuthStatus());
    }
    /**
     * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
     * @param options Optionally provide additional options for the sign in request.
     *
     * You can use the options parameter to request that we show the sign up form instead of the sign in form:
     * ```javascript
     * import { LOGIN_HINT_SIGNUP } from 'bitski';
     *
     * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
     * ```
     */
    async signIn(options) {
        return this.getSDK().then((sdk) => sdk.signIn(options));
    }
    /**
     * Gets the current signed in user. Will reject if we are not signed in.
     */
    async getUser() {
        return this.getSDK().then((sdk) => sdk.getUser());
    }
    /**
     * Connects to bitski to get a valid access token if possible.
     */
    async connect() {
        return this.getSDK().then((sdk) => sdk.connect());
    }
    /**
     * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
     * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
     */
    signInRedirect(options) {
        this.getSDK().then((sdk) => sdk.signInRedirect(options));
    }
    /**
     * Call from your oauth redirect page.
     */
    async redirectCallback() {
        return this.getSDK().then((sdk) => sdk.redirectCallback());
    }
    /**
     * Retrieves the current access token for the user, if logged in.
     */
    async getCurrentAccessToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentAccessToken());
    }
    /**
     * Retrieves the current ID token for the user, if logged in.
     */
    getCurrentIdToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentIdToken());
    }
    /**
     * Retrieves the current refresh token for the user, if logged in.
     * Requires that the user has approved your application for offline access.
     */
    getCurrentRefreshToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentRefreshToken());
    }
    /**
     * Register a callback to be called on sign out. This is a good practice,
     * since there may be situations where you are signed out unexpectedly.
     * @param fn Your callback function
     */
    addSignOutHandler(fn) {
        return this.getSDK().then((sdk) => sdk.addSignOutHandler(fn));
    }
    /**
     * Remove a registered signout callback
     * @param fn Your callback function
     */
    removeSignOutHandler(fn) {
        return this.getSDK().then((sdk) => sdk.removeSignOutHandler(fn));
    }
    /**
     * Sign the current user out of your application.
     */
    signOut() {
        return this.getSDK().then((sdk) => sdk.signOut());
    }
    async getSDK() {
        const sdk = await this.sdk;
        if (!sdk) {
            throw new Error('Bitski SDK not available');
        }
        return sdk;
    }
}
exports.Bitski = Bitski;
// Note: duplicated so we don't include the whole module
exports.LOGIN_HINT_SIGNUP = 'signup';
function networkFromName(networkName) {
    switch (networkName) {
        case '':
        case 'mainnet':
            return network_1.Mainnet;
        case 'goerli':
            return network_1.Goerli;
        case 'polygon':
            return network_1.Polygon;
        case 'mumbai':
            return network_1.Mumbai;
        case 'bnb':
            return network_1.BinanceSmartChain;
        case 'bnbt':
            return network_1.BinanceSmartChainTestnet;
        default:
            throw new Error(`Unsupported network name ${networkName}. Try passing a \`network\` in the options instead.`);
    }
}
function networkFromProviderOptions(options) {
    if (typeof options === 'string') {
        return networkFromName(options);
    }
    if (options === null || options === void 0 ? void 0 : options.network) {
        return options.network;
    }
    if (options === null || options === void 0 ? void 0 : options.networkName) {
        return networkFromName(options.networkName);
    }
}
//# sourceMappingURL=index.js.map