import { processCallback } from './-private/utils/callback';
import { loadScript } from './load';
import { BitskiProvider } from './provider';
import { ConnectButton } from './-private/components/connect-button';
import { AuthenticationStatus, OAuthSignInMethod } from './-private/constants';
// Import these directly so we don't load the whole provider bundle
import { BinanceSmartChain, BinanceSmartChainTestnet, Goerli, Mainnet, Mumbai, Polygon, } from 'bitski-provider/lib/network';
import { ProviderErrorCode } from 'bitski-provider';
import { toHex } from './-private/utils/numbers';
export { AuthenticationError, AuthenticationErrorCode, } from './-private/errors/authentication-error';
export { ParseError, ParseErrorCode } from './-private/errors/parse-error';
export { SignerError, SignerErrorCode } from './-private/errors/signer-error';
export { BinanceSmartChain, BinanceSmartChainTestnet, Mainnet, Goerli, Polygon, Mumbai, AuthenticationStatus, OAuthSignInMethod, };
export class Bitski {
    /**
     * @param clientId OAuth Client ID
     * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
     * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
     * Note: Make sure your app is approved for the scopes you are requesting first.
     * @param options Other OAuth settings. Don't change these unless you know what you are doing.
     */
    constructor(clientId, redirectUri, additionalScopes, options) {
        this.sdk = loadScript().then((BitskiSDK) => {
            return BitskiSDK ? new BitskiSDK(clientId, redirectUri, additionalScopes, options) : null;
        });
    }
    /**
     * Alternative to using our static callback.html file. Call this from your own redirect page.
     */
    static callback() {
        processCallback();
    }
    /**
     * Returns a new web3 provider for a given network.
     * @param options options for the provider, or a network name
     */
    getProvider(options) {
        var _a;
        if (typeof window !== 'undefined' && ((_a = window.Bitski) === null || _a === void 0 ? void 0 : _a.getProvider)) {
            return window.Bitski.getProvider(options);
        }
        const network = networkFromProviderOptions(options);
        if (!this.provider) {
            this.provider = new BitskiProvider(this.sdk, network !== null && network !== void 0 ? network : Mainnet, typeof options === 'string' ? undefined : options);
        }
        else if (network) {
            this.provider
                .request({
                method: 'wallet_switchChain',
                params: [{ chainId: toHex(network.chainId) }],
            })
                .catch(async (error) => {
                var _a, _b;
                if (error.code === ProviderErrorCode.ChainDoesNotExist) {
                    await ((_a = this.provider) === null || _a === void 0 ? void 0 : _a.request({
                        method: 'wallet_addChain',
                        params: [
                            {
                                chainId: toHex(network.chainId),
                                rpcUrls: [network.rpcUrl],
                            },
                        ],
                    }));
                    await ((_b = this.provider) === null || _b === void 0 ? void 0 : _b.request({
                        method: 'wallet_switchChain',
                        params: [{ chainId: toHex(network.chainId) }],
                    }));
                }
            });
            this.provider.start();
        }
        return this.provider;
    }
    /**
     * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
     * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
     * a callback to get notified of login events.
     * @param options {ConnectButtonOptions} Optional configuration for the button
     * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
     */
    getConnectButton(options, callback) {
        return new ConnectButton(this.sdk, options, callback);
    }
    /**
     * Signs in or connects to bitski depending on the user's auth state.
     * Since it may open a popup, this method must be called from user interaction handler,
     * such as a click or tap handler.
     * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
     */
    async start(options) {
        return this.getSDK().then((sdk) => sdk.signInOrConnect(undefined, options));
    }
    /**
     * Check the logged in state of the user
     */
    async getAuthStatus() {
        return this.getSDK().then((sdk) => sdk.getAuthStatus());
    }
    /**
     * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
     * @param options Optionally provide additional options for the sign in request.
     *
     * You can use the options parameter to request that we show the sign up form instead of the sign in form:
     * ```javascript
     * import { LOGIN_HINT_SIGNUP } from 'bitski';
     *
     * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
     * ```
     */
    async signIn(options) {
        return this.getSDK().then((sdk) => sdk.signIn(options));
    }
    /**
     * Gets the current signed in user. Will reject if we are not signed in.
     */
    async getUser() {
        return this.getSDK().then((sdk) => sdk.getUser());
    }
    /**
     * Connects to bitski to get a valid access token if possible.
     */
    async connect() {
        return this.getSDK().then((sdk) => sdk.connect());
    }
    /**
     * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
     * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
     */
    signInRedirect(options) {
        this.getSDK().then((sdk) => sdk.signInRedirect(options));
    }
    /**
     * Call from your oauth redirect page.
     */
    async redirectCallback() {
        return this.getSDK().then((sdk) => sdk.redirectCallback());
    }
    /**
     * Retrieves the current access token for the user, if logged in.
     */
    async getCurrentAccessToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentAccessToken());
    }
    /**
     * Retrieves the current ID token for the user, if logged in.
     */
    getCurrentIdToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentIdToken());
    }
    /**
     * Retrieves the current refresh token for the user, if logged in.
     * Requires that the user has approved your application for offline access.
     */
    getCurrentRefreshToken() {
        return this.getSDK().then((sdk) => sdk.getCurrentRefreshToken());
    }
    /**
     * Register a callback to be called on sign out. This is a good practice,
     * since there may be situations where you are signed out unexpectedly.
     * @param fn Your callback function
     */
    addSignOutHandler(fn) {
        return this.getSDK().then((sdk) => sdk.addSignOutHandler(fn));
    }
    /**
     * Remove a registered signout callback
     * @param fn Your callback function
     */
    removeSignOutHandler(fn) {
        return this.getSDK().then((sdk) => sdk.removeSignOutHandler(fn));
    }
    /**
     * Sign the current user out of your application.
     */
    signOut() {
        return this.getSDK().then((sdk) => sdk.signOut());
    }
    async getSDK() {
        const sdk = await this.sdk;
        if (!sdk) {
            throw new Error('Bitski SDK not available');
        }
        return sdk;
    }
}
// Note: duplicated so we don't include the whole module
export const LOGIN_HINT_SIGNUP = 'signup';
function networkFromName(networkName) {
    switch (networkName) {
        case '':
        case 'mainnet':
            return Mainnet;
        case 'goerli':
            return Goerli;
        case 'polygon':
            return Polygon;
        case 'mumbai':
            return Mumbai;
        case 'bnb':
            return BinanceSmartChain;
        case 'bnbt':
            return BinanceSmartChainTestnet;
        default:
            throw new Error(`Unsupported network name ${networkName}. Try passing a \`network\` in the options instead.`);
    }
}
function networkFromProviderOptions(options) {
    if (typeof options === 'string') {
        return networkFromName(options);
    }
    if (options === null || options === void 0 ? void 0 : options.network) {
        return options.network;
    }
    if (options === null || options === void 0 ? void 0 : options.networkName) {
        return networkFromName(options.networkName);
    }
}
