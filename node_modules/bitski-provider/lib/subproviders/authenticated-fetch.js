"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticatedFetchSubprovider = void 0;
const provider_engine_1 = require("@bitski/provider-engine");
const retry_1 = __importDefault(require("async/retry"));
const constants_1 = require("../constants");
const server_error_1 = require("../errors/server-error");
/*
 * Subprovider that fetches over HTTP and manages authentication headers
 */
class AuthenticatedFetchSubprovider extends provider_engine_1.FetchSubprovider {
    constructor(rpcUrl, debug, accessTokenProvider, defaultHeaders = {}) {
        super({ rpcUrl });
        this.authenticatedMethods = constants_1.AUTHENTICATED_METHODS;
        this.accessTokenProvider = accessTokenProvider;
        this.defaultHeaders = defaultHeaders;
    }
    handleRequest(payload, next, end) {
        if (this.requiresAuthentication(payload)) {
            return this.handleAuthenticatedRequest(payload, next, end);
        }
        else {
            return this.handleUnauthenticatedRequest(payload, next, end);
        }
    }
    handleAuthenticatedRequest(payload, next, end) {
        this.accessTokenProvider
            .getAccessToken()
            .then((accessToken) => {
            const parameters = this.generateParameters(payload, accessToken);
            return this.sendRequest(parameters, next, end);
        })
            .catch((error) => {
            end(error);
        });
    }
    handleUnauthenticatedRequest(payload, next, end) {
        const parameters = this.generateParameters(payload);
        return this.sendRequest(parameters, next, end);
    }
    requiresAuthentication(payload) {
        return this.authenticatedMethods.some((method) => method === payload.method);
    }
    generateParameters(payload, accessToken) {
        // overwrite id to not conflict with other concurrent users
        const newPayload = this.createPayload(payload);
        // remove extra parameter from request
        delete newPayload.origin;
        let headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        };
        headers = Object.assign({}, headers, this.defaultHeaders);
        const originDomain = payload.origin;
        if (this.originHttpHeaderKey && originDomain) {
            headers[this.originHttpHeaderKey] = originDomain;
        }
        if (accessToken) {
            headers.Authorization = `Bearer ${accessToken}`;
        }
        const requestParameters = {
            body: JSON.stringify(newPayload),
            headers,
            method: 'POST',
        };
        return requestParameters;
    }
    sendRequest(parameters, next, end) {
        (0, retry_1.default)({
            errorFilter: this.isErrorRetriable,
            interval: 1000,
            times: 5,
        }, (cb) => this._submitRequest(parameters, cb), (err, result) => {
            // ends on retriable error
            if (err && this.isErrorRetriable(err)) {
                const retriesExhaustedErr = new server_error_1.ServerError(err.message, 200, this.rpcUrl, true);
                return end(retriesExhaustedErr);
            }
            if (err && this.isUnauthorizedError(err)) {
                return this.accessTokenProvider.invalidateToken().then(() => {
                    return end(err);
                });
            }
            // otherwise continue normally
            return end(err, result);
        });
    }
    isErrorRetriable(err) {
        const errMsg = err.toString();
        return constants_1.RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
    }
    isUnauthorizedError(err) {
        return constants_1.UNAUTHORIZED_ERRORS.some((phrase) => err.message.includes(phrase));
    }
}
exports.AuthenticatedFetchSubprovider = AuthenticatedFetchSubprovider;
//# sourceMappingURL=authenticated-fetch.js.map